0001                               *************************************
0002                               * COPYRIGHT (C) MOTOROLA, INC. 1979 *
0003                               *************************************
0004                               
0005                               *************************************
0006                               * THIS IS THE BASE ASSIST09 ROM.
0007                               * IT MAY RUN WITH OR WITHOUT THE
0008                               * EXTENSION ROM WHICH
0009                               * WHEN PRESENT WILL BE AUTOMATICALLY
0010                               * INCORPORATED BY THE BLDVTR
0011                               * SUBROUTINE.
0012                               *************************************
0013                               
0014                               *********************************************
0015                               * GLOBAL MODULE EQUATES
0016                               ********************************************
0017 f000                          ROMBEG  EQU     $F000           ; ROM START ASSEMBLY ADDRESS
0018 fffff700                          RAMOFS  EQU     -$900          ; ROM OFFSET TO RAM WORK PAGE
0019 1000                          ROMSIZ  EQU     4096            ; ROM SIZE
0020 e000                          ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
0021 e808                          ACIA    EQU     $E808           ; DEFAULT ACIA ADDRESS
0022 e800                          PTM     EQU     $E800           ; DEFAULT PTM ADDRESS
0023 0000                          DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0024 0005                          DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
0025 003e                          PROMPT  EQU     '>              ; PROMPT CHARACTER
0026 0008                          NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
0027                               
0028 e810                          PIA     EQU $E810               ; PIA addresses
0029 e810                          PRA     EQU PIA
0030 e810                          DDRA    EQU PIA 
0031 e811                          CRA     EQU PIA+1
0032 e812                          PRB     EQU PIA+2
0033 e812                          DDRB    EQU PIA+2
0034 e813                          CRB     EQU PIA+3
0035                               
0036                               *********************************************
0037                               
0038                               *********************************************
0039                               * MISCELANEOUS EQUATES
0040                               *********************************************
0041 0004                          EOT     EQU     $04             ; END OF TRANSMISSION
0042 0007                          BELL    EQU     $07             ; BELL CHARACTER
0043 000a                          LF      EQU     $0A             ; LINE FEED
0044 000d                          CR      EQU     $0D             ; CARRIAGE RETURN
0045 0010                          DLE     EQU     $10             ; DATA LINK ESCAPE
0046 0018                          CAN     EQU     $18             ; CANCEL (CTL-X)
0047                               
0048                               * PTM ACCESS DEFINITIONS
0049 e801                          PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0050 e800                          PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0051 e801                          PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0052 e802                          PTMTM1  EQU     PTM+2           ; LATCH 1
0053 e804                          PTMTM2  EQU     PTM+4           ; LATCH 2
0054 e806                          PTMTM3  EQU     PTM+6           ; LATCH 3
0055 008c                          SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
0056                               
0057                               * PIA
0058                               
0059                               
0060                               *******************************************
0061                               * ASSIST09 MONITOR SWI FUNCTIONS
0062                               * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
0063                               * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
0064                               ******************************************
0065 0000                          INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0066 0001                          OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0067 0002                          PDATA1  EQU     2               ; OUTPUT STRING
0068 0003                          PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0069 0004                          OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0070 0005                          OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0071 0006                          PCRLF   EQU     6               ; OUTPUT CR/LF
0072 0007                          SPACE   EQU     7               ; OUTPUT A SPACE
0073 0008                          MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0074 0009                          VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
0075 000a                          BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
0076 000b                          PAUSE   EQU     11              ; TASK PAUSE FUNCTION
0077 000b                          NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
0078                               
0079                               * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
0080                               * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
0081                               * RELATIVE POSITIONING MUST BE MAINTAINED
0082                               
0083 0000                          .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
0084 0002                          .CMDL1  EQU     2               ; FIRST COMMAND LIST
0085 0004                          .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0086 0006                          .SWI3   EQU     6               ; SWI3 ROUTINE
0087 0008                          .SWI2   EQU     8               ; SWI2 ROUTINE
0088 000a                          .FIRQ   EQU     10              ; FIRQ ROUTINE
0089 000c                          .IRQ    EQU     12              ; IRQ ROUTINE
0090 000e                          .SWI    EQU     14              ; SWI ROUTINE
0091 0010                          .NMI    EQU     16              ; NMI ROUTINE
0092 0012                          .RESET  EQU     18              ; RESET ROUTINE
0093 0014                          .CION   EQU     20              ; CONSOLE ON
0094 0016                          .CIDTA  EQU     22              ; CONSOLE INPUT DATA
0095 0018                          .CIOFF  EQU     24              ; CONSOLE INPUT OFF
0096 001a                          .COON   EQU     26              ; CONSOLE OUTPUT ON
0097 001c                          .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
0098 001e                          .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
0099 0020                          .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0100 0022                          .BSON   EQU     34              ; PUNCH/LOAD ON
0101 0024                          .BSDTA  EQU     36              ; PUNCH/LOAD DATA
0102 0026                          .BSOFF  EQU     38              ; PUNCH/LOAD OFF
0103 0028                          .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
0104 002a                          .EXPAN  EQU     42              ; EXPRESSION ANALYZER
0105 002c                          .CMDL2  EQU     44              ; SECOND COMMAND LIST
0106 002e                          .ACIA   EQU     46              ; ACIA ADDRESS
0107 0030                          .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0108 0032                          .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0109 0034                          .PTM    EQU     52              ; PTM ADDRESS
0110 001b                          NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0111 0034                          HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
0112                               
0113                               ******************************************
0114                               *           WORK AREA
0115                               * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
0116                               * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
0117                               * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
0118                               * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
0119                               * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
0120                               * DEFINED HEREIN.
0121                               ******************************************
0122 e700                          WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
0123                               *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
0124 e800                                  ORG     WORKPG+256      ; READY PAGE DEFINITIONS
0125                               
0126                               * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
0127                               * FOR PROPER INITIALIZATION
0128 e7fc                                  ORG     *-4
0129 e7fc                          PAUSER  EQU     *               ; PAUSE ROUTINE
0130 e7fb                                  ORG     *-1
0131 e7fb                          SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
0132 e7fa                                  ORG     *-1
0133 e7fa                          BKPTCT  EQU     *               ; BREAKPOINT COUNT
0134 e7f8                                  ORG     *-2             ; SLEVEL EQU
0135 e7f8                          SLEVEL  EQU     *               ; STACK TRACE LEVEL
0136 e7c2                                  ORG     -NUMVTR*2+*
0137 e7c2                          VECTAB  EQU     *               ; VECTOR TABLE
0138 e7b2                                  ORG     -2*NUMBKP+*
0139 e7b2                          BKPTBL  EQU     *               ; BREAKPOINT TABLE
0140 e7a2                                  ORG     -2*NUMBKP+*
0141 e7a2                          BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
0142 e7a0                                  ORG     *-2
0143 e7a0                          WINDOW  EQU     *               ; WINDOW
0144 e79e                                  ORG     *-2
0145 e79e                          ADDR    EQU     *               ; ADDRESS POINTER VALUE
0146 e79d                                  ORG     *-1
0147 e79d                          BASEPG  EQU     *               ; BASE PAGE VALUE
0148 e79b                                  ORG     *-2
0149 e79b                          NUMBER  EQU     *               ; BINARY BUILD AREA
0150 e799                                  ORG     *-2
0151 e799                          LASTOP  EQU     *               ; LAST OPCODE TRACED
0152 e797                                  ORG     *-2
0153 e797                          RSTACK  EQU     *               ; RESET STACK POINTER
0154 e795                                  ORG     *-2
0155 e795                          PSTACK  EQU     *               ; COMMAND RECOVERY STACK
0156 e793                                  ORG     *-2
0157 e793                          PCNTER  EQU     *               ; LAST PROGRAM COUNTER
0158 e791                                  ORG     *-2
0159 e791                          TRACEC  EQU     *               ; TRACE COUNT
0160 e790                                  ORG     *-1
0161 e790                          SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
0162 e78f                                  ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
0163 e78f                          MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
0164 e78e                                  ORG     *-1
0165 e78e                          DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
0166 e766                                  ORG     *-40
0167 e766                          ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
0168 e751                                  ORG     *-21
0169 e751                          TSTACK  EQU     *               ; TEMPORARY STACK HOLD
0170 e751                          STACK   EQU     *               ; START OF INITIAL STACK
0171                               
0172                               ******************************************
0173                               * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
0174                               * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
0175                               * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
0176                               * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
0177                               * FROM THE ROM BEGINNING ADDRESS.
0178                               ********************************************
0179 e000                          	ORG	$E000
0180 e000 00                       	FCB	0
0181                               
0182 f000                                  ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
0183                               
0184                               *****************************************************
0185                               * BLDVTR - BUILD ASSIST09 VECTOR TABLE
0186                               * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
0187                               * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
0188                               * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
0189                               * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
0190                               * ASSIST09 EXECUTION.
0191                               * INPUT: S->VALID STACK RAM
0192                               * OUTPUT: U->VECTOR TABLE ADDRESS
0193                               * DPR->ASSIST09 WORK AREA PAGE
0194                               * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
0195                               * ALL REGISTERS VOLATILE
0196                               *************************************************
0197 f000 30 8d f7 be        [ 9 ] BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
0198 f004 1f 10              [ 6 ]         TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
0199 f006 1f 8b              [ 6 ]         TFR     A,DP            ; SETUP DPR
0200 f008 97 9d              [ 4 ]         STA     <BASEPG         ; STORE FOR QUICK REFERENCE
0201 f00a 33 84              [ 4 ]         LEAU    ,X              ; RETURN TABLE TO CALLER
0202 f00c 31 8c 4e           [ 5 ]         LEAY    <INITVT,PCR     ; LOAD FROM ADDR
0203 f00f ef 81              [ 8 ]         STU     ,X++            ; INIT VECTOR TABLE ADDRESS
0204 f011 c6 16              [ 2 ]         LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
0205 f013 34 04              [ 6 ]         PSHS    B               ; STORE INDEX ON STACK
0206 f015 1f 20              [ 6 ] BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
0207 f017 e3 a1              [ 9 ]         ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
0208 f019 ed 81              [ 8 ]         STD     ,X++            ; INTO VECTOR TABLE
0209 f01b 6a e4              [ 6 ]         DEC     ,S              ; COUNT DOWN
0210 f01d 26 f6              [ 3 ]         BNE     BLD2            ; BRANCH IF MORE TO INSERT
0211 f01f c6 0d              [ 2 ]         LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
0212 f021 a6 a0              [ 6 ] BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
0213 f023 a7 80              [ 6 ]         STA     ,X+             ; STORE INTO POSITION
0214 f025 5a                 [ 2 ]         DECB                    ; COUNT DOWN
0215 f026 26 f9              [ 3 ]         BNE     BLD3            ; LOOP UNTIL DONE
0216 f028 31 8d ef d4        [ 9 ]         LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
0217 f02c 8e 20 fe           [ 3 ]         LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
0218 f02f ac a1              [ 9 ]         CMPX    ,Y++            ; ? EXTENDED ROM HERE
0219 f031 26 02              [ 3 ]         BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
0220 f033 ad a4              [ 7 ]         JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
0221 f035 35 84              [ 8 ] BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
0222                               
0223                               *****************************************************
0224                               *                RESET ENTRY POINT
0225                               * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
0226                               * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
0227                               * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
0228                               * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
0229                               * CALL.
0230                               *******************************************************
0231 f037 32 8d f7 16        [ 9 ] RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
0232 f03b 8d c3              [ 7 ]         BSR     BLDVTR          ; BUILD VECTOR TABLE
0233                                   
0234                                       ; init PIA
0235 f03d 4f                 [ 2 ]         CLRA         ; init PIA, select DDR 
0236 f03e b7 e8 11           [ 5 ]         STA CRA 
0237 f041 b7 e8 13           [ 5 ]         STA CRB 
0238 f044 86 0f              [ 2 ]         LDA #$0F        ; PORTA0..3 = output
0239 f046 b7 e8 10           [ 5 ]         STA DDRA 
0240 f049 86 ff              [ 2 ]         LDA #$FF        ; PORT B = output 
0241 f04b b7 e8 12           [ 5 ]         STA DDRB 
0242 f04e 86 34              [ 2 ]         LDA #%00110100  ; select PRA/PRB 
0243 f050 b6 e8 10           [ 5 ]         LDA PRA 
0244 f053 b6 e8 12           [ 5 ]         LDA PRB 
0245                               
0246 f056 4f                 [ 2 ] RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
0247 f057 1f 8b              [ 6 ]         TFR     A,DP            ; DEFAULT TO PAGE ZERO
0248 f059 3f                 [19 ]         SWI                     ; PERFORM MONITOR FIREUP
0249 f05a 08                               FCB     MONITR          ; TO ENTER COMMAND PROCESSING
0250 f05b 20 f9              [ 3 ]         BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
0251                               
0252                               ******************************************************
0253                               *        INITVT - INITIAL VECTOR TABLE
0254                               * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
0255                               * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
0256                               * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
0257                               * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
0258                               * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
0259                               ************************************************
0260 f05d 01 56                    INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
0261 f05f 02 94                            FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
0262 f061 02 92                            FDB     SWI3R-*         ; DEFAULT SWI3
0263 f063 02 90                            FDB     SWI2R-*         ; DEFAULT SWI2
0264 f065 02 72                            FDB     FIRQR-*         ; DEFAULT FIRQ
0265 f067 02 8c                            FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
0266 f069 00 45                            FDB     SWIR-*          ; DEFAULT SWI ROUTINE
0267 f06b 02 2d                            FDB     NMIR-*          ; DEFAULT NMI ROUTINE
0268 f06d ff ca                            FDB     RESET-*         ; RESTART VECTOR
0269 f06f 02 92                            FDB     CION-*          ; DEFAULT CION
0270 f071 02 86                            FDB     CIDTA-*         ; DEFAULT CIDTA
0271 f073 02 ad                            FDB     CIOFF-*         ; DEFAULT CIOFF
0272 f075 02 8c                            FDB     COON-*          ; DEFAULT COON
0273 f077 02 aa                            FDB     CODTA-*         ; DEFAULT CODTA
0274 f079 02 a7                            FDB     COOFF-*         ; DEFAULT COOFF
0275 f07b 03 b1                            FDB     HSDTA-*         ; DEFAULT HSDTA
0276 f07d 02 ce                            FDB     BSON-*          ; DEFAULT BSON
0277 f07f 02 e9                            FDB     BSDTA-*         ; DEFAULT BSDTA
0278 f081 02 d6                            FDB     BSOFF-*         ; DEFAULT BSOFF
0279 f083 f7 79                            FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
0280 f085 04 94                            FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
0281 f087 01 2b                            FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
0282                               * CONSTANTS
0283 f089 e8 08                    INTVS   FDB     ACIA            ; DEFAULT ACIA
0284 f08b 00 05                            FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
0285 f08d 00 00                            FDB     0               ; DEFAULT ECHO
0286 f08f e8 00                            FDB     PTM             ; DEFAULT PTM
0287 f091 00 00                            FDB     0               ; INITIAL STACK TRACE LEVEL
0288 f093 00                               FCB     0               ; INITIAL BREAKPOINT COUNT
0289 f094 00                               FCB     0               ; SWI BREAKPOINT LEVEL
0290 f095 39                               FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
0291 f096                          INTVE   EQU     *
0292                               *B
0293                               ***********************************************
0294                               *            ASSIST09 SWI HANDLER
0295                               * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
0296                               * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
0297                               * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
0298                               * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
0299                               * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
0300                               * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
0301                               * INPUT: MACHINE STATE DEFINED FOR SWI
0302                               * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
0303                               * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
0304                               * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
0305                               * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
0306                               ************************************************
0307                               * SWI FUNCTION VECTOR TABLE
0308 f096 01 96                    SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
0309 f098 01 b3                            FDB     ZOTCH1-SWIVTB   ; OUTCH
0310 f09a 01 cd                            FDB     ZPDTA1-SWIVTB   ; PDATA1
0311 f09c 01 c5                            FDB     ZPDATA-SWIVTB   ; PDATA
0312 f09e 01 77                            FDB     ZOT2HS-SWIVTB   ; OUT2HS
0313 f0a0 01 75                            FDB     ZOT4HS-SWIVTB   ; OUT4HS
0314 f0a2 01 c2                            FDB     ZPCRLF-SWIVTB   ; PCRLF
0315 f0a4 01 7b                            FDB     ZSPACE-SWIVTB   ; SPACE
0316 f0a6 00 55                            FDB     ZMONTR-SWIVTB   ; MONITR
0317 f0a8 01 7f                            FDB     ZVSWTH-SWIVTB   ; VCTRSW
0318 f0aa 02 58                            FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
0319 f0ac 01 d3                            FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
0320                               
0321 f0ae 6a 8d f6 de        [11 ] SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
0322 f0b2 17 02 27           [ 9 ]         LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
0323                               * CHECK FOR BREAKPOINT TRAP
0324 f0b5 ee 6a              [ 6 ]         LDU     10,S            ; LOAD PROGRAM COUNTER
0325 f0b7 33 5f              [ 5 ]         LEAU    -1,U            ; BACK TO SWI ADDRESS
0326 f0b9 0d fb              [ 6 ]         TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
0327 f0bb 26 11              [ 3 ]         BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
0328 f0bd 17 06 b2           [ 9 ]         LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0329 f0c0 50                 [ 2 ]         NEGB                    ; OBTAIN POSITIVE COUNT
0330 f0c1 5a                 [ 2 ] SWILP   DECB                    ; COUNT DOWN
0331 f0c2 2b 0a              [ 3 ]         BMI     SWIDNE          ; BRANCH WHEN DONE
0332 f0c4 11 a3 a1           [10 ]         CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
0333 f0c7 26 f8              [ 3 ]         BNE     SWILP           ; BRANCH IF NOT
0334 f0c9 ef 6a              [ 6 ]         STU     10,S            ; SET PROGRAM COUNTER BACK
0335 f0cb 16 02 20           [ 5 ]         LBRA    ZBKPNT          ; GO DO BREAKPOINT
0336 f0ce 0f fb              [ 6 ] SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
0337 f0d0 37 06              [ 7 ]         PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
0338 f0d2 c1 0b              [ 2 ]         CMPB    #NUMFUN         ; ? TOO HIGH
0339 f0d4 10 22 02 11        [ 6 ]         LBHI    ERROR           ; YES, DO BREAKPOINT
0340 f0d8 ef 6a              [ 6 ]         STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
0341 f0da 58                 [ 2 ]         ASLB                    ; FUNCTION CODE TIMES TWO
0342 f0db 33 8c b8           [ 5 ]         LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
0343 f0de ec c5              [ 6 ]         LDD     B,U             ; LOAD OFFSET
0344 f0e0 6e cb              [ 7 ]         JMP     D,U             ; JUMP TO ROUTINE
0345                               
0346                               **********************************************
0347                               * REGISTERS TO FUNCTION ROUTINES:
0348                               *  DP-> WORK AREA PAGE
0349                               *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
0350                               *  S=AS FROM SWI INTERRUPT
0351                               *********************************************
0352                               
0353                               **************************************************
0354                               *            [SWI FUNCTION 8]
0355                               *              MONITOR ENTRY
0356                               *  FIREUP THE ASSIST09 MONITOR.
0357                               *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
0358                               *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
0359                               *   1) INITIALIZE CONSOLE I/O
0360                               *   2) OPTIONALLY PRINT SIGNON
0361                               *   3) INITIALIZE PTM FOR SINGLE STEPPING
0362                               *   4) ENTER COMMAND PROCESSOR
0363                               * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
0364                               *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
0365                               *************************************************
0366                               
0367 f0e2 41 53 53 49 53 54        SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
0368 f0ea 04                               FCB     EOT
0369 f0eb 10 df 97           [ 6 ] ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
0370 f0ee 6d 61              [ 7 ]         TST     1,S             ; ? INIT CONSOLE AND SEND MSG
0371 f0f0 26 0d              [ 3 ]         BNE     ZMONT2          ; BRANCH IF NOT
0372 f0f2 ad 9d f6 e0        [15 ]         JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
0373 f0f6 ad 9d f6 e2        [15 ]         JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
0374 f0fa 30 8c e5           [ 5 ]         LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
0375 f0fd 3f                 [19 ]         SWI                     ; PERFORM
0376 f0fe 03                               FCB     PDATA           ; PRINT STRING
0377 f0ff 9e f6              [ 5 ] ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
0378 f101 27 0b              [ 3 ]         BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
0379 f103 6f 02              [ 7 ]         CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
0380 f105 6f 03              [ 7 ]         CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
0381 f107 cc 93 a6           [ 3 ]         LDD     #$93A6          ; SETUP TIMER 1 MODE
0382 f10a a7 01              [ 5 ]         STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
0383 f10c e7 84              [ 4 ]         STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
0384                               * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
0385                                       ;CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
0386                               
0387                               
0388                               * FALL INTO COMMAND PROCESSOR
0389                               
0390                               ***************************************************
0391                               *          COMMAND HANDLER
0392                               *  BREAKPOINTS ARE REMOVED AT THIS TIME.
0393                               *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
0394                               *  UNTIL A SEPARATOR ON THE STACK.
0395                               *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
0396                               *  CALL IT OR GIVE '?' RESPONSE.
0397                               *  DURING COMMAND SEARCH:
0398                               *      B=OFFSET TO NEXT ENTRY ON X
0399                               *      U=SAVED S
0400                               *      U-1=ENTRY SIZE+2
0401                               *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
0402                               *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
0403                               *      U-4=START OF COMMAND STORE
0404                               *      S+0=END OF COMMAND STORE
0405                               ***********************************************
0406                               
0407 f10e 3f                 [19 ] CMD     SWI                     ; TO NEW LINE
0408 f10f 06                               FCB     PCRLF           ; FUNCTION
0409                               * DISARM THE BREAKPOINTS
0410 f110 17 06 5f           [ 9 ] CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0411 f113 2a 0c              [ 3 ]         BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
0412 f115 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
0413 f116 d7 fa              [ 4 ]         STB     <BKPTCT         ; FLAG AS DISARMED
0414 f118 5a                 [ 2 ] CMDDDL  DECB                    ; ? FINISHED
0415 f119 2b 06              [ 3 ]         BMI     CMDNOL          ; BRANCH IF SO
0416 f11b a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
0417 f11d a7 b1              [10 ]         STA     [,Y++]          ; STORE BACK OVER "SWI"
0418 f11f 20 f7              [ 3 ]         BRA     CMDDDL          ; LOOP UNTIL DONE
0419 f121 ae 6a              [ 6 ] CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
0420 f123 9f 93              [ 5 ]         STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
0421 f125 86 3e              [ 2 ]         LDA     #PROMPT         ; LOAD PROMPT CHARACTER
0422 f127 3f                 [19 ]         SWI                     ; SEND TO OUTPUT HANDLER
0423 f128 01                               FCB     OUTCH           ; FUNCTION
0424 f129 33 e4              [ 4 ]         LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
0425 f12b df 95              [ 5 ]         STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
0426 f12d 4f                 [ 2 ]         CLRA                    ; PREPARE ZERO
0427 f12e 5f                 [ 2 ]         CLRB                    ; PREPARE ZERO
0428 f12f dd 9b              [ 5 ]         STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
0429 f131 dd 8f              [ 5 ]         STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
0430 f133 dd 91              [ 5 ]         STD     <TRACEC         ; CLEAR TRACE COUNT
0431 f135 c6 02              [ 2 ]         LDB     #2              ; SET D TO TWO
0432 f137 34 07              [ 8 ]         PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
0433                               * CHECK FOR "QUICK" COMMANDS.
0434 f139 17 04 6d           [ 9 ]         LBSR    READ            ; OBTAIN FIRST CHARACTER
0435 f13c 30 8d 05 9a        [ 9 ]         LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
0436 f140 81 2e              [ 2 ]         CMPA    #'.             ; ? QUICK TRACE
0437 f142 27 5a              [ 3 ]         BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
0438 f144 30 8d 05 02        [ 9 ]         LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
0439 f148 81 2f              [ 2 ]         CMPA    #'/             ; ? OPEN LAST USED MEMORY
0440 f14a 27 52              [ 3 ]         BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
0441                               * PROCESS NEXT CHARACTER
0442 f14c 81 20              [ 2 ] CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
0443 f14e 23 14              [ 3 ]         BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
0444 f150 34 02              [ 6 ]         PSHS   A                ; BUILD ONTO STACK
0445 f152 6c 5f              [ 7 ]         INC    -1,U             ; COUNT THIS CHARACTER
0446 f154 81 2f              [ 2 ]         CMPA   #'/              ; ? MEMORY COMMAND
0447 f156 27 4f              [ 3 ]         BEQ    CMDMEM           ; BRANCH IF SO
0448 f158 17 04 24           [ 9 ]         LBSR   BLDHXC           ; TREAT AS HEX VALUE
0449 f15b 27 02              [ 3 ]         BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
0450 f15d 6a 5e              [ 7 ]         DEC    -2,U             ; FLAG AS INVALID NUMBER
0451 f15f 17 04 47           [ 9 ] CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
0452 f162 20 e8              [ 3 ]         BRA    CMD2             ; TEST NEXT CHARACTER
0453                               * GOT COMMAND, NOW SEARCH TABLES
0454 f164 80 0d              [ 2 ] CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
0455 f166 a7 5d              [ 5 ]         STA    -3,U             ; SETUP FLAG
0456 f168 9e c4              [ 5 ]         LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
0457 f16a e6 80              [ 6 ] CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
0458 f16c 2a 10              [ 3 ]         BPL    CMDSME           ; BRANCH IF NOT LIST END
0459 f16e 9e ee              [ 5 ]         LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
0460 f170 5c                 [ 2 ]         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
0461 f171 27 f7              [ 3 ]         BEQ     CMDSCH          ; BRANCH IF SO
0462 f173 10 de 95           [ 6 ] CMDBAD  LDS     <PSTACK         ; RESTORE STACK
0463 f176 30 8d 01 5e        [ 9 ]         LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
0464 f17a 3f                 [19 ]         SWI                     ; SEND OUT
0465 f17b 02                               FCB     PDATA1          ; TO CONSOLE
0466 f17c 20 90              [ 3 ]         BRA     CMD             ; AND TRY AGAIN
0467                               * SEARCH NEXT ENTRY
0468 f17e 5a                 [ 2 ] CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
0469 f17f e1 5f              [ 5 ]         CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
0470 f181 24 03              [ 3 ]         BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
0471 f183 3a                 [ 3 ] CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
0472 f184 20 e4              [ 3 ]         BRA     CMDSCH          ; AND TRY NEXT
0473 f186 31 5d              [ 5 ] CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
0474 f188 a6 5f              [ 5 ]         LDA     -1,U            ; LOAD SIZE+2
0475 f18a 80 02              [ 2 ]         SUBA    #2              ; TO ACTUAL SIZE ENTERED
0476 f18c a7 5e              [ 5 ]         STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
0477 f18e 5a                 [ 2 ] CMDCMP  DECB                    ; DOWN ONE BYTE
0478 f18f a6 80              [ 6 ]         LDA     ,X+             ; NEXT COMMAND CHARACTER
0479 f191 a1 a2              [ 6 ]         CMPA    ,-Y             ; ? SAME AS THAT ENTERED
0480 f193 26 ee              [ 3 ]         BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
0481 f195 6a 5e              [ 7 ]         DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
0482 f197 26 f5              [ 3 ]         BNE     CMDCMP          ; BRANCH IF MORE TO TEST
0483 f199 3a                 [ 3 ]         ABX                     ; TO NEXT ENTRY
0484 f19a ec 1e              [ 6 ]         LDD     -2,X            ; LOAD OFFSET
0485 f19c 30 8b              [ 8 ]         LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
0486 f19e 6d 5d              [ 7 ] CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
0487 f1a0 32 c4              [ 4 ]         LEAS    ,U              ; DELETE STACK WORK AREA
0488 f1a2 ad 1e              [ 8 ]         JSR     -2,X            ; CALL COMMAND
0489 f1a4 16 ff 7a           [ 5 ]         LBRA    CMDNOL          ; GO GET NEXT COMMAND
0490 f1a7 6d 5e              [ 7 ] CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
0491 f1a9 2b c8              [ 3 ]         BMI     CMDBAD          ; BRANCH ERROR IF NOT
0492 f1ab 30 88 ae           [ 5 ]         LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
0493 f1ae dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER ENTERED
0494 f1b0 20 ec              [ 3 ]         BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
0495                               
0496                               ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
0497                               **    DPR->ASSIST09 DIRECT PAGE WORK AREA
0498                               **    Z=1 CARRIAGE RETURN ENTERED
0499                               **    Z=0 NON CARRIAGE RETURN DELIMITER
0500                               **    S=NORMAL RETURN ADDRESS
0501                               ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
0502                               ** AN ERROR FLAG (*).
0503                               **************************************************
0504                               *       ASSIST09 COMMAND TABLES
0505                               * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
0506                               * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
0507                               * THESE BY USING THE VECTOR SWAP FUNCTION.
0508                               *
0509                               * ENTRY FORMAT:
0510                               *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
0511                               *    +1...COMMAND STRING
0512                               *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
0513                               *
0514                               * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
0515                               * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
0516                               *        SECOND COMMAND TABLE.
0517                               * THE -2 TERMINATES COMMAND SEARCHES.
0518                               *****************************************************
0519                               
0520                               * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
0521                               * LIST ENTRY.
0522                               
0523 f1b2 fe                       CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
0524                               
0525                               * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
0526                               * LIST ENTRY.
0527                               
0528 f1b3                          CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
0529 f1b3 04                               FCB     4
0530 f1b4 42                               FCC     /B/             ; 'BREAKPOINT' COMMAND
0531 f1b5 05 66                            FDB     CBKPT-*
0532 f1b7 04                               FCB     4
0533 f1b8 43                               FCC     /C/             ; 'CALL' COMMAND
0534 f1b9 04 30                            FDB     CCALL-*
0535 f1bb 04                               FCB     4
0536 f1bc 44                               FCC     /D/             ; 'DISPLAY' COMMAND
0537 f1bd 04 b6                            FDB     CDISP-*
0538 f1bf 04                               FCB     4
0539 f1c0 45                               FCC     /E/             ; 'ENCODE' COMMAND
0540 f1c1 05 b8                            FDB     CENCDE-*
0541 f1c3 04                               FCB     4
0542 f1c4 46                               FCC     /F/             ; 'FLEX' COMMAND
0543 f1c5 06 3f                            FDB     FLEX-*
0544 f1c7 04                               FCB     4
0545 f1c8 47                               FCC     /G/             ; 'GO' COMMAND
0546 f1c9 03 e7                            FDB     CGO-*
0547 f1cb 04                               FCB     4
0548 f1cc 4c                               FCC     /L/             ; 'LOAD' COMMAND
0549 f1cd 04 f2                            FDB     CLOAD-*
0550 f1cf 04                               FCB     4
0551 f1d0 4d                               FCC     /M/             ; 'MEMORY' COMMAND
0552 f1d1 04 22                            FDB     CMEM-*
0553 f1d3 04                               FCB     4
0554 f1d4 4e                               FCC     /N/             ; 'NULLS' COMMAND
0555 f1d5 05 12                            FDB     CNULLS-*
0556 f1d7 04                               FCB     4
0557 f1d8 4f                               FCC     /O/             ; 'OFFSET' COMMAND
0558 f1d9 05 1f                            FDB     COFFS-*
0559 f1db 04                               FCB     4
0560 f1dc 50                               FCC     /P/             ; 'PUNCH' COMMAND
0561 f1dd 04 c4                            FDB     CPUNCH-*
0562 f1df 04                               FCB     4
0563 f1e0 52                               FCC     /R/             ; 'REGISTERS' COMMAND
0564 f1e1 02 99                            FDB     CREG-*
0565 f1e3 04                               FCB     4
0566 f1e4 53                               FCC     /S/             ; 'STLEVEL' COMMAND
0567 f1e5 05 07                            FDB     CSTLEV-*
0568 f1e7 04                               FCB     4
0569 f1e8 54                               FCC     /T/             ; 'TRACE' COMMAND
0570 f1e9 04 eb                            FDB     CTRACE-*
0571 f1eb 04                               FCB     4
0572 f1ec 56                               FCC     /V/             ; 'VERIFY' COMMAND
0573 f1ed 04 e4                            FDB     CVER-*
0574 f1ef 04                               FCB     4
0575 f1f0 57                               FCC     /W/             ; 'WINDOW' COMMAND
0576 f1f1 04 7d                            FDB     CWINDO-*
0577 f1f3 ff                               FCB     -1              ; END, CONTINUE WITH THE SECOND
0578                               
0579                               *************************************************
0580                               *             [SWI FUNCTIONS 4 AND 5]
0581                               *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
0582                               *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
0583                               * INPUT: X->BYTE OR WORD TO DECODE
0584                               * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
0585                               *         X->NEXT BYTE OR WORD
0586                               *************************************************
0587 f1f4 a6 80              [ 6 ] ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
0588 f1f6 34 06              [ 7 ]         PSHS    D               ; SAVE - DO NOT REREAD
0589 f1f8 c6 10              [ 2 ]         LDB     #16             ; SHIFT BY 4 BITS
0590 f1fa 3d                 [11 ]         MUL                     ; WITH MULTIPLY
0591 f1fb 8d 04              [ 7 ]         BSR     ZOUTHX          ; SEND OUT AS HEX
0592 f1fd 35 06              [ 7 ]         PULS    D               ; RESTORE BYTES
0593 f1ff 84 0f              [ 2 ]         ANDA    #$0F            ; ISOLATE RIGHT HEX
0594 f201 8b 90              [ 2 ] ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
0595 f203 19                 [ 2 ]         DAA                     ; ADJUST
0596 f204 89 40              [ 2 ]         ADCA    #$40            ; PREPARE CHARACTER BITS
0597 f206 19                 [ 2 ]         DAA                     ; ADJUST
0598 f207 6e 9d f5 d3        [11 ] SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
0599                               
0600 f20b 8d e7              [ 7 ] ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
0601 f20d 8d e5              [ 7 ] ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
0602 f20f af 64              [ 6 ]         STX     4,S             ; UPDATE USERS X REGISTER
0603                               * FALL INTO SPACE ROUTINE
0604                               
0605                               *************************************************
0606                               *            [SWI FUNCTION 7]
0607                               *         SPACE - SEND BLANK TO OUTPUT HANDLER
0608                               * INPUT: NONE
0609                               * OUTPUT: BLANK SEND TO CONSOLE HANDLER
0610                               *************************************************
0611 f211 86 20              [ 2 ] ZSPACE  LDA     #'              ; LOAD BLANK
0612 f213 20 3d              [ 3 ]         BRA     ZOTCH2          ; SEND AND RETURN
0613                               
0614                               ***********************************************
0615                               *             [SWI FUNCTION 9]
0616                               *          SWAP VECTOR TABLE ENTRY
0617                               * INPUT: A=VECTOR TABLE CODE (OFFSET)
0618                               * X=0 OR REPLACEMENT VALUE
0619                               * OUTPUT: X=PREVIOUS VALUE
0620                               ***********************************************
0621 f215 a6 61              [ 5 ] ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
0622 f217 81 34              [ 2 ]         CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
0623 f219 22 39              [ 3 ]         BHI     ZOTCH3          ; IGNORE CALL IF SO
0624 f21b 10 9e c2           [ 6 ]         LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
0625 f21e ee a6              [ 6 ]         LDU     A,Y             ; U=OLD ENTRY
0626 f220 ef 64              [ 6 ]         STU     4,S             ; RETURN OLD VALUE TO CALLERS X
0627 f222 af 7e              [ 6 ]         STX     -2,S            ; ? X=0
0628 f224 27 2e              [ 3 ]         BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
0629 f226 af a6              [ 6 ]         STX     A,Y             ; REPLACE ENTRY
0630 f228 20 2a              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM SWI
0631                               *D
0632                               
0633                               ************************************************
0634                               *               [SWI FUNCTION 0]
0635                               *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
0636                               * NULLS AND RUBOUTS ARE IGNORED.
0637                               * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
0638                               * CARRIAGE RETURN.
0639                               * UNLESS WE ARE LOADING FROM TAPE.
0640                               ************************************************
0641 f22a 8d 5d              [ 7 ] ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
0642 f22c 8d 5f              [ 7 ] ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
0643 f22e 24 fa              [ 3 ]         BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
0644 f230 4d                 [ 2 ]         TSTA                    ; ? TEST FOR NULL
0645 f231 27 f9              [ 3 ]         BEQ     ZINCH           ; IGNORE NULL
0646 f233 81 7f              [ 2 ]         CMPA    #$7F            ; ? RUBOUT
0647 f235 27 f5              [ 3 ]         BEQ     ZINCH           ; BRANCH YES TO IGNORE
0648 f237 a7 61              [ 5 ]         STA     1,S             ; STORE INTO CALLERS A
0649 f239 0d 8f              [ 6 ]         TST     <MISFLG         ; ? LOAD IN PROGRESS
0650 f23b 26 17              [ 3 ]         BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
0651 f23d 81 0d              [ 2 ]         CMPA    #CR             ; ? CARRIAGE RETURN
0652 f23f 26 04              [ 3 ]         BNE     ZIN2            ; NO, TEST ECHO BYTE
0653 f241 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0654 f243 8d c2              [ 7 ]         BSR     SEND            ; ALWAYS ECHO LINE FEED
0655 f245 0d f4              [ 6 ] ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
0656 f247 26 0b              [ 3 ]         BNE     ZOTCH3          ; NO, RETURN
0657                               * FALL THROUGH TO OUTCH
0658                               ************************************************
0659                               *            [SWI FUNCTION 1]
0660                               *        OUTCH - OUTPUT CHARACTER FROM A
0661                               * INPUT: NONE
0662                               * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
0663                               * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
0664                               ************************************************
0665 f249 a6 61              [ 5 ] ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
0666 f24b 30 8c 09           [ 5 ]         LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
0667 f24e 81 0a              [ 2 ]         CMPA    #LF             ; ? LINE FEED
0668 f250 27 0f              [ 3 ]         BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
0669 f252 8d b3              [ 7 ] ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
0670 f254 0c 90              [ 6 ] ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
0671 f256 3b                 [15 ]         RTI                     ; RETURN FROM "SWI" FUNCTION
0672                               
0673                               **************************************************
0674                               * [SWI FUNCTION 6]
0675                               * PCRLF - SEND CR/LF TO CONSOLE HANDLER
0676                               * INPUT: NONE
0677                               * OUTPUT: CR AND LF SENT TO HANDLER
0678                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0679                               **************************************************
0680 f257 04                       ZPCRLS  FCB     EOT             ; NULL STRING
0681 f258 30 8c fc           [ 5 ] ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
0682                               * FALL INTO CR/LF CODE
0683                               
0684                               **************************************************
0685                               * [SWI FUNCTION 3]
0686                               * PDATA - OUTPUT CR/LF AND STRING
0687                               * INPUT: X->STRING
0688                               * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
0689                               * HANDLER.
0690                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0691                               * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
0692                               * PROPER PUNCH DATA.
0693                               **************************************************
0694                               
0695 f25b 86 0d              [ 2 ] ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
0696 f25d 8d a8              [ 7 ]         BSR     SEND            ; SEND IT
0697 f25f 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0698                               * FALL INTO PDATA1
0699                               
0700                               *************************************************
0701                               * [SWI FUNCTION 2]
0702                               * PDATA1 - OUTPUT STRING TILL EOT ($04)
0703                               * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
0704                               * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
0705                               * SECOND IS RECEIVED.
0706                               * INPUT: X->STRING
0707                               * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
0708                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0709                               *************************************************
0710                               
0711 f261 8d a4              [ 7 ] ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
0712 f263 a6 80              [ 6 ] ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
0713 f265 81 04              [ 2 ]         CMPA    #EOT            ; ? EOT
0714 f267 26 f8              [ 3 ]         BNE     ZPDTLP          ; LOOP IF NOT
0715                               * FALL INTO PAUSE CHECK FUNCTION
0716                               
0717                               ********************************************
0718                               * [SWI FUNCTION 12]
0719                               * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
0720                               * FOR FREEZE CONDITION OR CTL-X BREAK
0721                               * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
0722                               * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
0723                               * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
0724                               * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
0725                               * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
0726                               * HANDLER.
0727                               * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
0728                               ******************************************
0729                               
0730 f269 8d 1e              [ 7 ] ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
0731 f26b 8d 06              [ 7 ]         BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
0732 f26d 1f a9              [ 6 ]         TFR     CC,B            ; PREPARE TO REPLACE CC
0733 f26f e7 e4              [ 4 ]         STB     ,S              ; OVERLAY OLD ONE ON STACK
0734 f271 20 e1              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM "SWI"
0735                               
0736                               * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
0737                               * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
0738                               * VOLATILE: U,X,D
0739 f273 8d 18              [ 7 ] CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
0740 f275 24 05              [ 3 ]         BCC     CHKRTN          ; BRANCH NO TO RETURN
0741 f277 81 18              [ 2 ]         CMPA    #CAN            ; ? CTL-X FOR ABORT
0742 f279 26 02              [ 3 ]         BNE     CHKWT           ; BRANCH NO TO PAUSE
0743 f27b 53                 [ 2 ] CHKSEC  COMB                    ; SET CARRY
0744 f27c 39                 [ 5 ] CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
0745 f27d 8d 0a              [ 7 ] CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
0746 f27f 8d 0c              [ 7 ]         BSR     XQCIDT          ; ? KEY FOR START
0747 f281 24 fa              [ 3 ]         BCC     CHKWT           ; LOOP UNTIL RECEIVED
0748 f283 81 18              [ 2 ]         CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
0749 f285 27 f4              [ 3 ]         BEQ     CHKSEC          ; BRANCH YES
0750 f287 4f                 [ 2 ]         CLRA                    ; SET C=0 FOR NO ABORT
0751 f288 39                 [ 5 ]         RTS                     ; AND RETURN
0752                               
0753                               * SAVE MEMORY WITH JUMPS
0754 f289 6e 9d f5 5d        [11 ] XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
0755 f28d ad 9d f5 47        [15 ] XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
0756 f291 84 7f              [ 2 ]         ANDA  #$7F              ; STRIP PARITY
0757 f293 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0758                               
0759                               ********************************************
0760                               * NMI DEFAULT INTERRUPT HANDLER
0761                               * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
0762                               * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
0763                               * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
0764                               * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
0765                               * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
0766                               *********************************************
0767                               
0768 f294 4f 50 2d 04              MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
0769                               
0770 f298 8d 42              [ 7 ] NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
0771 f29a 0d 8f              [ 6 ]         TST     <MISFLG         ; ? THRU A BREAKPOINT
0772 f29c 26 34              [ 3 ]         BNE     NMICON          ; BRANCH IF SO TO CONTINUE
0773 f29e 0d 90              [ 6 ]         TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
0774 f2a0 2b 29              [ 3 ]         BMI     NMITRC          ; BRANCH YES
0775 f2a2 30 6c              [ 5 ]         LEAX    12,S            ; OBTAIN USERS STACK POINTER
0776 f2a4 9c f8              [ 6 ]         CMPX    <SLEVEL         ; ? TO TRACE HERE
0777 f2a6 25 23              [ 3 ]         BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
0778 f2a8 30 8c e9           [ 5 ]         LEAX    MSHOWP,PCR      ; LOAD OP PREP
0779 f2ab 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
0780 f2ac 02                               FCB     PDATA1          ; FUNCTION
0781 f2ad 09 8e              [ 6 ]         ROL     <DELIM          ; SAVE CARRY BIT
0782 f2af 30 8d f4 e6        [ 9 ]         LEAX    LASTOP,PCR      ; POINT TO LAST OP
0783 f2b3 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
0784 f2b4 05                               FCB     OUT4HS          ; FUNCTION
0785 f2b5 8d 17              [ 7 ]         BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
0786 f2b7 25 37              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0787 f2b9 06 8e              [ 6 ]         ROR     <DELIM          ; RESTORE CARRY BIT
0788 f2bb 25 33              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0789 f2bd 9e 91              [ 5 ]         LDX     <TRACEC         ; LOAD TRACE COUNT
0790 f2bf 27 2f              [ 3 ]         BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
0791 f2c1 30 1f              [ 5 ]         LEAX    -1,X            ; MINUS ONE
0792 f2c3 9f 91              [ 5 ]         STX     <TRACEC         ; REFRESH
0793 f2c5 27 29              [ 3 ]         BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
0794 f2c7 8d aa              [ 7 ]         BSR     CHKABT          ; ? ABORT THE TRACE
0795 f2c9 25 25              [ 3 ]         BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
0796 f2cb 16 04 0c           [ 5 ] NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
0797                               
0798 f2ce 17 01 ce           [ 9 ] REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
0799 f2d1 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0800                               
0801                               * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
0802                               
0803 f2d2 0f 8f              [ 6 ] NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
0804 f2d4 17 03 00           [ 9 ]         LBSR    ARMBK2         ; ARM BREAKPOINTS
0805 f2d7 3b                 [15 ] RTI     RTI                    ; AND CONTINUE USERS PROGRAM
0806                               
0807                               * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
0808                               * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
0809                               * HANDLER.
0810                               * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
0811                               * OUTPUT: DPR LOADED TO WORK PAGE
0812                               
0813 f2d8 3f 07 20 04              ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
0814                               
0815 f2dc e6 8d f4 bd        [ 9 ] LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
0816 f2e0 1f 9b              [ 6 ]         TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
0817 f2e2 a1 63              [ 5 ]         CMPA    3,S             ; ? IS STACK VALID
0818 f2e4 27 3a              [ 3 ]         BEQ     RTS             ; YES, RETURN
0819 f2e6 10 de 97           [ 6 ]         LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
0820 f2e9 30 8c ec           [ 5 ] ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
0821 f2ec 3f                 [19 ]         SWI                     ; SEND OUT BEFORE REGISTERS
0822 f2ed 03                               FCB     PDATA           ; ON NEXT LINE
0823                               * FALL INTO BREAKPOINT HANDLER
0824                               
0825                               **********************************************
0826                               * [SWI FUNCTION 10]
0827                               * BREAKPOINT PROGRAM FUNCTION
0828                               * PRINT REGISTERS AND GO TO COMMAND HANLER
0829                               ***********************************************
0830                               
0831 f2ee 8d de              [ 7 ] ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
0832 f2f0 16 fe 1d           [ 5 ] ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
0833                               
0834                               ********************************************
0835                               * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
0836                               * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
0837                               ********************************************
0838 f2f3                          SWI2R   EQU     *               ; SWI2 ENTRY
0839 f2f3                          SWI3R   EQU     *               ; SWI3 ENTRY
0840 f2f3                          IRQR    EQU     *               ; IRQ ENTRY
0841 f2f3 8d e7              [ 7 ] RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
0842 f2f5 20 f7              [ 3 ]         BRA     ZBKPNT          ; FORCE A BREAKPOINT
0843                               
0844                               ******************************************
0845                               * FIRQ HANDLER
0846                               * JUST RETURN FOR THE FIRQ INTERRUPT
0847                               ******************************************
0848 f2d7                          FIRQR   EQU     RTI             ; IMMEDIATE RETURN
0849                               
0850                               **************************************************
0851                               * DEFAULT I/O DRIVERS
0852                               **************************************************
0853                               * CIDTA - RETURN CONSOLE INPUT CHARACTER
0854                               * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
0855                               * U VOLATILE
0856                               
0857 f2f7 de f0              [ 5 ] CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0858 f2f9 a6 c4              [ 4 ]         LDA     ,U              ; LOAD STATUS REGISTER
0859 f2fb 44                 [ 2 ]         LSRA                    ; TEST RECEIVER REGISTER FLAG
0860 f2fc 24 02              [ 3 ]         BCC     CIRTN           ; RETURN IF NOTHING
0861 f2fe a6 41              [ 5 ]         LDA     1,U             ; LOAD DATA BYTE
0862 f300 39                 [ 5 ] CIRTN   RTS                     ; RETURN TO CALLER
0863                               
0864                               * CION - INPUT CONSOLE INITIALIZATION
0865                               * COON - OUTPUT CONSOLE INITIALIZATION
0866                               * A,X VOLATILE
0867 f301                          CION   EQU      *
0868                               COON   
0869 f301 9e f6              [ 5 ]        LDX      <VECTAB+.PTM
0870 f303 86 93              [ 2 ]        LDA	#$93
0871 f305 a7 01              [ 5 ]        STA      PTMC2-PTM,X
0872 f307 cc 00 02           [ 3 ]        LDD	#2
0873 f30a ed 04              [ 6 ]        STD      PTMTM2-PTM,X
0874 f30c 4f                 [ 2 ]        CLRA	
0875 f30d a7 84              [ 4 ]        STA      PTMC13-PTM,X
0876 f30f 86 03              [ 2 ]        LDA      #3              ; RESET ACIA CODE
0877 f311 9e f0              [ 5 ]        LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0878 f313 a7 84              [ 4 ]        STA      ,X              ; STORE INTO STATUS REGISTER
0879 f315 86 15              [ 2 ]        LDA      #$15            ; SET CONTROL
0880 f317 a7 84              [ 4 ]        STA      ,X              ; REGISTER UP
0881                               
0882 f319 8e 27 10           [ 3 ]        LDX      #10000          ; small pause before using ACIA
0883 f31c 30 1f              [ 5 ] COON2  LEAX     -1,X
0884 f31e 26 fc              [ 3 ]        BNE      COON2
0885                               
0886 f320 39                 [ 5 ] RTS    RTS                      ; RETURN TO CALLER
0887                               
0888                               * THE FOLLOWING HAVE NO DUTIES TO PERFORM
0889 f320                          CIOFF EQU       RTS             ; CONSOLE INPUT OFF
0890 f320                          COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
0891                               
0892                               * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
0893                               * INPUT: A=CHARACTER TO SEND
0894                               * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
0895                               * ALL REGISTERS TRANSPARENT
0896                               
0897 f321 34 47              [10 ] CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
0898 f323 de f0              [ 5 ]         LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
0899 f325 8d 1b              [ 7 ]         BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
0900 f327 81 10              [ 2 ]         CMPA    #DLE            ; ? DATA LINE ESCAPE
0901 f329 27 12              [ 3 ]         BEQ     CODTRT          ; YES, RETURN
0902 f32b d6 f2              [ 4 ]         LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
0903 f32d 81 0d              [ 2 ]         CMPA    #CR             ; ? CR
0904 f32f 26 02              [ 3 ]         BNE     CODTPD          ; BRANCH NO
0905 f331 d6 f3              [ 4 ]         LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
0906 f333 4f                 [ 2 ] CODTPD  CLRA                    ; CREATE NULL
0907 f334 e7 e4              [ 4 ]         STB     ,S              ; SAVE COUNT
0908 f336 8c                               FCB     SKIP2           ; ENTER LOOP
0909 f337 8d 09              [ 7 ] CODTLP  BSR     CODTAO          ; SEND NULL
0910 f339 6a e4              [ 6 ]         DEC     ,S              ; ? FINISHED
0911 f33b 2a fa              [ 3 ]         BPL     CODTLP          ; NO, CONTINUE WITH MORE
0912 f33d 35 c7              [12 ] CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
0913                               
0914 f33f 17 ff 47           [ 9 ] CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
0915 f342 e6 c4              [ 4 ] CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
0916 f344 c5 02              [ 2 ]         BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
0917 f346 27 f7              [ 3 ]         BEQ     CODTAD          ; RELEASE CONTROL IF NOT
0918 f348 a7 41              [ 5 ]         STA     1,U             ; STORE INTO DATA REGISTER
0919 f34a 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0920                               *E
0921                               
0922                               * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
0923                               * A IS VOLATILE
0924                               
0925 f34b 86 11              [ 2 ] BSON    LDA     #$11            ; SET READ CODE
0926 f34d 6d 66              [ 7 ]         TST     6,S             ; ? READ OR VERIFY
0927 f34f 26 01              [ 3 ]         BNE     BSON2           ; BRANCH YES
0928 f351 4c                 [ 2 ]         INCA                    ; SET TO WRITE
0929 f352 3f                 [19 ] BSON2   SWI                     ; PERFORM OUTPUT
0930 f353 01                               FCB     OUTCH           ; FUNCTION
0931 f354 0c 8f              [ 6 ]         INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
0932 f356 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0933                               
0934                               * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
0935                               * A,X VOLATILE
0936                               
0937 f357 86 14              [ 2 ] BSOFF   LDA     #$14            ; TO DC4 - STOP
0938 f359 3f                 [19 ]         SWI                     ; SEND OUT
0939 f35a 01                               FCB     OUTCH           ; FUNCTION
0940 f35b 4a                 [ 2 ]         DECA                    ; CHANGE TO DC3 (X-OFF)
0941 f35c 3f                 [19 ]         SWI                     ; SEND OUT
0942 f35d 01                               FCB     OUTCH           ; FUNCTION
0943 f35e 0a 8f              [ 6 ]         DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
0944 f360 8e 61 a8           [ 3 ]         LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
0945 f363 30 1f              [ 5 ] BSOFLP  LEAX    -1,X            ; COUNT DOWN
0946 f365 26 fc              [ 3 ]         BNE     BSOFLP          ; LOOP TILL DONE
0947 f367 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0948                               
0949                               * BSDTA - READ/VERIFY/PUNCH HANDLER
0950                               * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
0951                               * S+4=START ADDRESS
0952                               * S+2=STOP ADDRESS
0953                               * S+0=RETURN ADDRESS
0954                               * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
0955                               * REGISTERS ARE VOLATILE
0956 f368 ee 62              [ 6 ] BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
0957 f36a 6d 66              [ 7 ]         TST     6,S             ; ? PUNCH
0958 f36c 27 54              [ 3 ]         BEQ     BSDPUN          ; BRANCH YES
0959                               
0960                               * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
0961                               * S+1=BYTE COUNTER
0962                               * S+0=CHECKSUM
0963                               * U HOLDS OFFSET
0964 f36e 32 7d              [ 5 ]         LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
0965 f370 3f                 [19 ] BSDLD1  SWI                     ; GET NEXT CHARACTER
0966 f371 00                               FCB     INCHNP          ; FUNCTION
0967 f372 81 53              [ 2 ] BSDLD2  CMPA    #'S             ; ? START OF S1/S9
0968 f374 26 fa              [ 3 ]         BNE     BSDLD1          ; BRANCH NOT
0969 f376 3f                 [19 ]         SWI                     ; GET NEXT CHARACTER
0970 f377 00                               FCB     INCHNP          ; FUNCTION
0971 f378 81 39              [ 2 ]         CMPA    #'9             ; ? HAVE S9
0972 f37a 27 22              [ 3 ]         BEQ     BSDSRT          ; YES, RETURN GOOD CODE
0973 f37c 81 31              [ 2 ]         CMPA    #'1             ; ? HAVE NEW RECORD
0974 f37e 26 f2              [ 3 ]         BNE     BSDLD2          ; BRANCH IF NOT
0975 f380 6f e4              [ 6 ]         CLR     ,S              ; CLEAR CHECKSUM
0976 f382 8d 21              [ 7 ]         BSR     BYTE            ; OBTAIN BYTE COUNT
0977 f384 e7 61              [ 5 ]         STB     1,S             ; SAVE FOR DECREMENT
0978                               
0979                               * READ ADDRESS
0980 f386 8d 1d              [ 7 ]         BSR     BYTE            ; OBTAIN HIGH VALUE
0981 f388 e7 62              [ 5 ]         STB     2,S             ; SAVE IT
0982 f38a 8d 19              [ 7 ]         BSR     BYTE            ; OBTAIN LOW VALUE
0983 f38c a6 62              [ 5 ]         LDA     2,S             ; MAKE D=VALUE
0984 f38e 31 cb              [ 8 ]         LEAY    D,U             ; Y=ADDRESS+OFFSET
0985                               * STORE TEXT
0986 f390 8d 13              [ 7 ] BSDNXT  BSR     BYTE            ; NEXT BYTE
0987 f392 27 0c              [ 3 ]         BEQ     BSDEOL          ; BRANCH IF CHECKSUM
0988 f394 6d 69              [ 7 ]         TST     9,S             ; ? VERIFY ONLY
0989 f396 2b 02              [ 3 ]         BMI     BSDCMP          ; YES, ONLY COMPARE
0990 f398 e7 a4              [ 4 ]         STB     ,Y              ; STORE INTO MEMORY
0991 f39a e1 a0              [ 6 ] BSDCMP  CMPB    ,Y+             ; ? VALID RAM
0992 f39c 27 f2              [ 3 ]         BEQ     BSDNXT          ; YES, CONTINUE READING
0993 f39e 35 92              [10 ] BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
0994 f3a0 4c                 [ 2 ] BSDEOL  INCA                    ; ? VALID CHECKSUM
0995 f3a1 27 cd              [ 3 ]         BEQ     BSDLD1          ; BRANCH YES
0996 f3a3 20 f9              [ 3 ]         BRA     BSDSRT          ; RETURN Z=0 INVALID
0997                               
0998                               * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
0999 f3a5 8d 12              [ 7 ] BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
1000 f3a7 c6 10              [ 2 ]         LDB     #16            ; PREPARE SHIFT
1001 f3a9 3d                 [11 ]         MUL                    ; OVER TO A
1002 f3aa 8d 0d              [ 7 ]         BSR     BYTHEX         ; OBTAIN SECOND HEX
1003 f3ac 34 04              [ 6 ]         PSHS    B              ; SAVE HIGH HEX
1004 f3ae ab e0              [ 6 ]         ADDA    ,S+            ; COMBINE BOTH SIDES
1005 f3b0 1f 89              [ 6 ]         TFR     A,B            ; SEND BACK IN B
1006 f3b2 ab 62              [ 5 ]         ADDA    2,S            ; COMPUTE NEW CHECKSUM
1007 f3b4 a7 62              [ 5 ]         STA     2,S            ; STORE BACK
1008 f3b6 6a 63              [ 7 ]         DEC     3,S            ; DECREMENT BYTE COUNT
1009 f3b8 39                 [ 5 ] BYTRTS  RTS                    ; RETURN TO CALLER
1010                               
1011 f3b9 3f                 [19 ] BYTHEX  SWI                    ; GET NEXT HEX
1012 f3ba 00                               FCB     INCHNP         ; CHARACTER
1013 f3bb 17 01 d4           [ 9 ]         LBSR    CNVHEX         ; CONVERT TO HEX
1014 f3be 27 f8              [ 3 ]         BEQ     BYTRTS         ; RETURN IF VALID HEX
1015 f3c0 35 f2              [14 ]         PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
1016                               
1017                               * PUNCH STACK USE: S+8=TO ADDRESS
1018                               *                  S+6=RETURN ADDRESS
1019                               *                  S+4=SAVED PADDING VALUES
1020                               *                  S+2 FROM ADDRESS
1021                               *                  S+1=FRAME COUNT/CHECKSUM
1022                               *                  S+0=BYTE COUNT
1023                               
1024 f3c2 de f2              [ 5 ] BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
1025 f3c4 ae 64              [ 6 ]         LDX     4,S             ; X=FROM ADDRESS
1026 f3c6 34 56              [11 ]         PSHS    U,X,D           ; CREATE STACK WORK AREA
1027 f3c8 cc 00 18           [ 3 ]         LDD     #24             ; SET A=0, B=24
1028 f3cb d7 f2              [ 4 ]         STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
1029 f3cd 3f                 [19 ]         SWI                     ; SEND NULLS OUT
1030 f3ce 01                               FCB     OUTCH           ; FUNCTION
1031 f3cf c6 04              [ 2 ]         LDB     #4              ; SETUP NEW LINE PAD TO 4
1032 f3d1 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
1033                               * CALCULATE SIZE
1034 f3d3 ec 68              [ 6 ] BSPGO   LDD     8,S             ; LOAD TO
1035 f3d5 a3 62              [ 7 ]         SUBD    2,S             ; MINUS FROM=LENGTH
1036 f3d7 10 83 00 18        [ 5 ]         CMPD    #24             ; ? MORE THAN 23
1037 f3db 25 02              [ 3 ]         BLO     BSPOK           ; NO, OK
1038 f3dd c6 17              [ 2 ]         LDB     #23             ; FORCE TO 23 MAX
1039 f3df 5c                 [ 2 ] BSPOK   INCB                    ; PREPARE COUNTER
1040 f3e0 e7 e4              [ 4 ]         STB     ,S              ; STORE BYTE COUNT
1041 f3e2 cb 03              [ 2 ]         ADDB    #3              ; ADJUST TO FRAME COUNT
1042 f3e4 e7 61              [ 5 ]         STB     1,S             ; SAVE
1043                               
1044                               *PUNCH CR,LF,NULS,S,1
1045 f3e6 30 8c 33           [ 5 ]        LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
1046 f3e9 3f                 [19 ]        SWI                      ; SEND OUT
1047 f3ea 03                              FCB      PDATA           ; FUNCTION
1048                               * SEND FRAME COUNT
1049 f3eb 5f                 [ 2 ]        CLRB                     ; INITIALIZE CHECKSUM
1050 f3ec 30 61              [ 5 ]        LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
1051 f3ee 8d 27              [ 7 ]        BSR      BSPUN2          ; SEND FRAME COUNT
1052                               *DATA ADDRESS
1053 f3f0 8d 25              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS HI
1054 f3f2 8d 23              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS LOW
1055                               *PUNCH DATA
1056 f3f4 ae 62              [ 6 ]        LDX      2,S             ; LOAD START DATA ADDRESS
1057 f3f6 8d 1f              [ 7 ] BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
1058 f3f8 6a e4              [ 6 ]        DEC      ,S              ; ? FINAL BYTE
1059 f3fa 26 fa              [ 3 ]        BNE      BSPMRE          ; LOOP IF NOT DONE
1060 f3fc af 62              [ 6 ]        STX      2,S             ; UPDATE FROM ADDRESS VALUE
1061                               *PUNCH CHECKSUM
1062 f3fe 53                 [ 2 ]        COMB                     ; COMPLEMENT
1063 f3ff e7 61              [ 5 ]        STB      1,S             ; STORE FOR SENDOUT
1064 f401 30 61              [ 5 ]        LEAX     1,S             ; POINT TO IT
1065 f403 8d 14              [ 7 ]        BSR      BSPUNC          ; SEND OUT AS HEX
1066 f405 ae 68              [ 6 ]        LDX      8,S             ; LOAD TOP ADDRESS
1067 f407 ac 62              [ 7 ]        CMPX     2,S             ; ? DONE
1068 f409 24 c8              [ 3 ]        BHS      BSPGO           ; BRANCH NOT
1069 f40b 30 8c 11           [ 5 ]        LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
1070 f40e 3f                 [19 ]        SWI                      ; SEND OUT STRING
1071 f40f 03                              FCB      PDATA           ; FUNCTION
1072 f410 ec 64              [ 6 ]        LDD      4,S             ; RECOVER PAD COUNTS
1073 f412 dd f2              [ 5 ]        STD      <VECTAB+.PAD    ; RESTORE
1074 f414 4f                 [ 2 ]        CLRA                     ; SET Z=1 FOR OK RETURN
1075 f415 35 d6              [13 ]        PULS     PC,U,X,D        ; RETURN WITH OK CODE
1076 f417 eb 84              [ 4 ] BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
1077 f419 16 fd d8           [ 5 ] BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
1078                               
1079 f41c 53 01 04                 BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
1080 f41f 53 39 30 33 30 30        BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
1081 f429 0d 0a 04                        FCB      CR,LF,EOT
1082                               
1083                               * HSDTA - HIGH SPEED PRINT MEMORY
1084                               * INPUT: S+4=START ADDRESS
1085                               * S+2=STOP ADDRESS
1086                               * S+0=RETURN ADDRESS
1087                               * X,D VOLATILE
1088                               
1089                               * SEND TITLE
1090                               
1091 f42c 3f                 [19 ] HSDTA   SWI                     ; SEND NEW LINE
1092 f42d 06                               FCB     PCRLF           ; FUNCTION
1093 f42e c6 06              [ 2 ]         LDB     #6              ; PREPARE 6 SPACES
1094 f430 3f                 [19 ] HSBLNK  SWI                     ; SEND BLANK
1095 f431 07                               FCB     SPACE           ; FUNCTION
1096 f432 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1097 f433 26 fb              [ 3 ]         BNE     HSBLNK          ; LOOP IF MORE
1098 f435 5f                 [ 2 ]         CLRB                    ; SETUP BYTE COUNT
1099 f436 1f 98              [ 6 ] HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
1100 f438 17 fd c6           [ 9 ]         LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
1101 f43b 3f                 [19 ]         SWI                     ; SEND BLANK
1102 f43c 07                               FCB     SPACE           ; FUNCTION
1103 f43d 3f                 [19 ]         SWI                     ; SEND ANOTHER
1104 f43e 07                               FCB     SPACE           ; BLANK
1105 f43f 5c                 [ 2 ]         INCB                    ; UP ANOTHER
1106 f440 c1 10              [ 2 ]         CMPB    #$10            ; ? PAST 'F'
1107 f442 25 f2              [ 3 ]         BLO     HSHTTL          ; LOOP UNTIL SO
1108 f444 3f                 [19 ] HSHLNE  SWI                     ; TO NEXT LINE
1109 f445 06                               FCB     PCRLF           ; FUNCTION
1110 f446 25 2f              [ 3 ]         BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
1111 f448 30 64              [ 5 ]         LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
1112 f44a 3f                 [19 ]         SWI                     ; PRINT OUT ADDRESS
1113 f44b 05                               FCB     OUT4HS          ; FUNCTION
1114 f44c ae 64              [ 6 ]         LDX     4,S             ; LOAD ADDRESS PROPER
1115 f44e c6 10              [ 2 ]         LDB     #16             ; NEXT SIXTEEN
1116 f450 3f                 [19 ] HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
1117 f451 04                               FCB     OUT2HS          ; FUNCTION
1118 f452 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1119 f453 26 fb              [ 3 ]         BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
1120 f455 3f                 [19 ]         SWI                     ; SEND BLANK
1121 f456 07                               FCB     SPACE           ; FUNCTION
1122 f457 ae 64              [ 6 ]         LDX     4,S             ; RELOAD FROM ADDRESS
1123 f459 c6 10              [ 2 ]         LDB     #16             ; COUNT
1124 f45b a6 80              [ 6 ] HSHCHR  LDA     ,X+             ; NEXT BYTE
1125 f45d 2b 04              [ 3 ]         BMI     HSHDOT          ; TOO LARGE, TO A DOT
1126 f45f 81 20              [ 2 ]         CMPA    #'              ; ? LOWER THAN A BLANK
1127 f461 24 02              [ 3 ]         BHS     HSHCOK          ; NO, BRANCH OK
1128 f463 86 2e              [ 2 ] HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
1129 f465 3f                 [19 ] HSHCOK  SWI                     ; SEND CHARACTER
1130 f466 01                               FCB     OUTCH           ; FUNCTION
1131 f467 5a                 [ 2 ]         DECB                    ; ? DONE
1132 f468 26 f1              [ 3 ]         BNE     HSHCHR          ; BRANCH NO
1133 f46a ac 62              [ 7 ]         CPX     2,S             ; ? PAST LAST ADDRESS
1134 f46c 24 09              [ 3 ]         BHS     HSDRTN          ; QUIT IF SO
1135 f46e af 64              [ 6 ]         STX     4,S             ; UPDATE FROM ADDRESS
1136 f470 a6 65              [ 5 ]         LDA     5,S             ; LOAD LOW BYTE ADDRESS
1137 f472 48                 [ 2 ]         ASLA                    ; ? TO SECTION BOUNDARY
1138 f473 26 cf              [ 3 ]         BNE     HSHLNE          ; BRANCH IF NOT
1139 f475 20 b5              [ 3 ]         BRA     HSDTA           ; BRANCH IF SO
1140 f477 3f                 [19 ] HSDRTN  SWI                     ; SEND NEW LINE
1141 f478 06                               FCB     PCRLF           ; FUNCTION
1142 f479 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
1143                               *F
1144                               
1145                               ***********************************************
1146                               *     A S S I S T 0 9    C O M M A N D S
1147                               ***********************************************
1148                               
1149                               *************REGISTERS - DISPLAY AND CHANGE REGISTERS
1150 f47a 8d 23              [ 7 ] CREG    BSR     REGPRT          ; PRINT REGISTERS
1151 f47c 4c                 [ 2 ]         INCA                    ; SET FOR CHANGE FUNCTION
1152 f47d 8d 21              [ 7 ]         BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
1153 f47f 39                 [ 5 ]         RTS                     ; RETURN TO COMMAND PROCESSOR
1154                               
1155                               ********************************************
1156                               * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
1157                               * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
1158                               * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
1159                               * DONE.
1160                               
1161                               * REGISTER MASK LIST CONSISTS OF:
1162                               * A) CHARACTERS DENOTING REGISTER
1163                               * B) ZERO FOR ONE BYTE, -1 FOR TWO
1164                               * C) OFFSET ON STACK TO REGISTER POSITION
1165                               * INPUT: SP+4=STACKED REGISTERS
1166                               * A=0 PRINT, A#0 PRINT AND CHANGE
1167                               * OUTPUT: (ONLY FOR REGISTER DISPLAY)
1168                               * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
1169                               * VOLATILE: D,X (CHANGE)
1170                               * B,X (DISPLAY)
1171                               *******************************************
1172                               
1173 f480 50 43 ff 13              REGMSK  FCB     'P,'C,-1,19     ; PC REG
1174 f484 41 00 0a                         FCB     'A,0,10         ; A REG
1175 f487 42 00 0b                         FCB     'B,0,11         ; B REG
1176 f48a 58 ff 0d                         FCB     'X,-1,13        ; X REG
1177 f48d 59 ff 0f                         FCB     'Y,-1,15        ; Y REG
1178 f490 55 ff 11                         FCB     'U,-1,17        ; U REG
1179 f493 53 ff 01                         FCB     'S,-1,1         ; S REG
1180 f496 43 43 00 09                      FCB     'C,'C,0,9       ; CC REG
1181 f49a 44 50 00 0c                      FCB     'D,'P,0,12      ; DP REG
1182 f49e 00                               FCB     0               ; END OF LIST
1183                               
1184 f49f 4f                 [ 2 ] REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
1185 f4a0 30 e8 10           [ 5 ] REGCHG  LEAX    4+12,S          ; READY STACK VALUE
1186 f4a3 34 32              [10 ]         PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
1187 f4a5 31 8c d8           [ 5 ]         LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
1188 f4a8 ec a0              [ 7 ] REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
1189 f4aa 4d                 [ 2 ]         TSTA                    ; ? END OF CHARACTERS
1190 f4ab 2f 04              [ 3 ]         BLE     REGP2           ; BRANCH NOT CHARACTER
1191 f4ad 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
1192 f4ae 01                               FCB     OUTCH           ; FUNCTION BYTE
1193 f4af 20 f7              [ 3 ]         BRA     REGP1           ; CHECK NEXT
1194 f4b1 86 2d              [ 2 ] REGP2   LDA     #'-             ; READY '-'
1195 f4b3 3f                 [19 ]         SWI                     ; SEND OUT
1196 f4b4 01                               FCB     OUTCH           ; WITH OUTCH
1197 f4b5 30 e5              [ 5 ]         LEAX    B,S             ; X->REGISTER TO PRINT
1198 f4b7 6d e4              [ 6 ]         TST     ,S              ; ? CHANGE OPTION
1199 f4b9 26 12              [ 3 ]         BNE     REGCNG          ; BRANCH YES
1200 f4bb 6d 3f              [ 7 ]         TST     -1,Y            ; ? ONE OR TWO BYTES
1201 f4bd 27 03              [ 3 ]         BEQ     REGP3           ; BRANCH ZERO MEANS ONE
1202 f4bf 3f                 [19 ]         SWI                     ; PERFORM WORD HEX
1203 f4c0 05                               FCB     OUT4HS          ; FUNCTION
1204 f4c1 8c                               FCB     SKIP2           ; SKIP BYTE PRINT
1205 f4c2 3f                 [19 ] REGP3   SWI                     ; PERFORM BYTE HEX
1206 f4c3 04                               FCB     OUT2HS          ; FUNCTION
1207 f4c4 ec a0              [ 7 ] REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
1208 f4c6 5d                 [ 2 ]         TSTB                    ; ? END OF ENTRIES
1209 f4c7 26 df              [ 3 ]         BNE     REGP1           ; LOOP IF MORE
1210 f4c9 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1211 f4ca 06                               FCB     PCRLF           ; FUNCTION
1212 f4cb 35 b2              [12 ] REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
1213                               
1214 f4cd 8d 40              [ 7 ] REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
1215 f4cf 27 10              [ 3 ]         BEQ     REGNXC          ; IF CHANGE THEN JUMP
1216 f4d1 81 0d              [ 2 ]         CMPA    #CR             ; ? NO MORE DESIRED
1217 f4d3 27 1e              [ 3 ]         BEQ     REGAGN          ; BRANCH NOPE
1218 f4d5 e6 3f              [ 5 ]         LDB     -1,Y            ; LOAD SIZE FLAG
1219 f4d7 5a                 [ 2 ]         DECB                    ; MINUS ONE
1220 f4d8 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
1221 f4d9 58                 [ 2 ]         ASLB                    ; TIMES TWO (=2 OR =4)
1222 f4da 3f                 [19 ] REGSKP  SWI                     ; PERFORM SPACES
1223 f4db 07                               FCB     SPACE           ; FUNCTION
1224 f4dc 5a                 [ 2 ]         DECB
1225 f4dd 26 fb              [ 3 ]         BNE     REGSKP          ; LOOP IF MORE
1226 f4df 20 e3              [ 3 ]         BRA     REG4            ; CONTINUE WITH NEXT REGISTER
1227 f4e1 a7 e4              [ 4 ] REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
1228                               *                               ; (ALWAYS > 0)
1229 f4e3 dc 9b              [ 5 ]         LDD     <NUMBER         ; OBTAIN BINARY RESULT
1230 f4e5 6d 3f              [ 7 ]         TST     -1,Y            ; ? TWO BYTES WORTH
1231 f4e7 26 02              [ 3 ]         BNE     REGTWO          ; BRANCH YES
1232 f4e9 a6 82              [ 6 ]         LDA     ,-X             ; SETUP FOR TWO
1233 f4eb ed 84              [ 5 ] REGTWO  STD     ,X              ; STORE IN NEW VALUE
1234 f4ed a6 e4              [ 4 ]         LDA     ,S              ; RECOVER DELIMITER
1235 f4ef 81 0d              [ 2 ]         CMPA    #CR             ; ? END OF CHANGES
1236 f4f1 26 d1              [ 3 ]         BNE     REG4            ; NO, KEEP ON TRUCK'N
1237                               * MOVE STACKED DATA TO NEW STACK IN CASE STACK
1238                               * POINTER HAS CHANGED
1239 f4f3 30 8d f2 5a        [ 9 ] REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
1240 f4f7 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT
1241 f4f9 35 02              [ 6 ] REGTF1  PULS    A               ; NEXT BYTE
1242 f4fb a7 80              [ 6 ]         STA     ,X+             ; STORE INTO TEMP
1243 f4fd 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1244 f4fe 26 f9              [ 3 ]         BNE     REGTF1          ; LOOP IF MORE
1245 f500 10 ee 88 ec        [ 7 ]         LDS     -20,X           ; LOAD NEW STACK POINTER
1246 f504 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT AGAIN
1247 f506 a6 82              [ 6 ] REGTF2 LDA      ,-X             ; NEXT TO STORE
1248 f508 34 02              [ 6 ]        PSHS     A               ; BACK ONTO NEW STACK
1249 f50a 5a                 [ 2 ]        DECB                     ; COUNT DOWN
1250 f50b 26 f9              [ 3 ]        BNE      REGTF2          ; LOOP IF MORE
1251 f50d 20 bc              [ 3 ]        BRA      REGRTN          ; GO RESTART COMMAND
1252                               
1253                               *********************************************
1254                               * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
1255                               * THE ACTIVE EXPRESSION HANDLER IS USED.
1256                               * INPUT: S=RETURN ADDRESS
1257                               * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
1258                               * (IF DELM NOT ZERO)
1259                               * "NUMBER"=WORD BINARY RESULT
1260                               * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
1261                               * REGISTERS ARE TRANSPARENT
1262                               **********************************************
1263                               * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
1264                               *
1265                               * THE FLAG "DELIM" IS USED AS FOLLOWS:
1266                               * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
1267                               * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
1268 f50f 4f                 [ 2 ] BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
1269 f510 8c                               FCB     SKIP2           ; SKIP NEXT INSTRUCTION
1270                               * BUILD WITH LEADING BLANKS
1271 f511 86 20              [ 2 ] BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
1272 f513 97 8e              [ 4 ]         STA     <DELIM          ; STORE AS DELIMITER
1273 f515 6e 9d f2 d3        [11 ]         JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
1274                               * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
1275                               * 1) HEX INPUT
1276                               * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
1277                               * 3) 'P' FOR PROGRAM COUNTER ADDRESS
1278                               * 4) 'W' FOR WINDOW VALUE
1279                               * 5) '@' FOR INDIRECT VALUE
1280                               
1281 f519 34 14              [ 8 ] EXP1    PSHS    X,B             ; SAVE REGISTERS
1282 f51b 8d 5c              [ 7 ] EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
1283 f51d 27 18              [ 3 ]         BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
1284                               * SKIP BLANKS IF DESIRED
1285 f51f 91 8e              [ 4 ]         CMPA    <DELIM          ; ? CORRECT DELIMITER
1286 f521 27 f8              [ 3 ]         BEQ     EXPDLM          ; YES, IGNORE IT
1287                               * TEST FOR M OR P
1288 f523 9e 9e              [ 5 ]         LDX     <ADDR           ; DEFAULT FOR 'M'
1289 f525 81 4d              [ 2 ]         CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
1290 f527 27 16              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1291 f529 9e 93              [ 5 ]         LDX     <PCNTER         ; DEFAULT FOR 'P'
1292 f52b 81 50              [ 2 ]         CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
1293 f52d 27 10              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1294 f52f 9e a0              [ 5 ]         LDX     <WINDOW         ; DEFAULT TO WINDOW
1295 f531 81 57              [ 2 ]         CMPA    #'W             ; ? WINDOW WANTED
1296 f533 27 0a              [ 3 ]         BEQ     EXPTDL
1297                               
1298 f535 35 94              [10 ] EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
1299                               * GOT HEX, NOW CONTINUE BUILDING
1300 f537 8d 44              [ 7 ] EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
1301 f539 27 fc              [ 3 ]         BEQ     EXP2            ; CONTINUE IF MORE
1302 f53b 20 0a              [ 3 ]         BRA     EXPCDL          ; SEARCH FOR +/-
1303                               * STORE VALUE AND CHECK IF NEED DELIMITER
1304 f53d ae 84              [ 5 ] EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
1305 f53f 9f 9b              [ 5 ] EXPTDL  STX     <NUMBER         ; STORE RESULT
1306 f541 0d 8e              [ 6 ]         TST     <DELIM          ; ? TO FORCE A DELIMITER
1307 f543 27 f0              [ 3 ]         BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
1308 f545 8d 62              [ 7 ]         BSR     READ            ; OBTAIN NEXT CHARACTER
1309                               * TEST FOR + OR -
1310 f547 9e 9b              [ 5 ] EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
1311 f549 81 2b              [ 2 ]         CMPA    #'+             ; ? ADD OPERATOR
1312 f54b 26 0e              [ 3 ]         BNE     EXPCHM          ; BRANCH NOT
1313 f54d 8d 23              [ 7 ]         BSR     EXPTRM          ; COMPUTE NEXT TERM
1314 f54f 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1315 f551 dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NEW TERM
1316 f553 30 8b              [ 8 ] EXPADD  LEAX    D,X             ; ADD TO X
1317 f555 9f 9b              [ 5 ]         STX     <NUMBER         ; STORE AS NEW RESULT
1318 f557 35 02              [ 6 ]         PULS    A               ; RESTORE DELIMITER
1319 f559 20 ec              [ 3 ]         BRA     EXPCDL          ; NOW TEST IT
1320 f55b 81 2d              [ 2 ] EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
1321 f55d 27 07              [ 3 ]         BEQ     EXPSUB          ; BRANCH IF SO
1322 f55f 81 40              [ 2 ]         CMPA    #'@             ; ? INDIRECTION DESIRED
1323 f561 27 da              [ 3 ]         BEQ     EXPTDI          ; BRANCH IF SO
1324 f563 5f                 [ 2 ]         CLRB                    ; SET DELIMITER RETURN
1325 f564 20 cf              [ 3 ]         BRA     EXPRTN          ; AND RETURN TO CALLER
1326 f566 8d 0a              [ 7 ] EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
1327 f568 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1328 f56a dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD UP NEXT TERM
1329 f56c 40                 [ 2 ]         NEGA                    ; NEGATE A
1330 f56d 50                 [ 2 ]         NEGB                    ; NEGATE B
1331 f56e 82 00              [ 2 ]         SBCA    #0              ; CORRECT FOR A
1332 f570 20 e1              [ 3 ]         BRA     EXPADD          ; GO ADD TO EXPRESSION
1333                               * COMPUTE NEXT EXPRESSION TERM
1334                               * OUTPUT: X=OLD VALUE
1335                               * 'NUMBER'=NEXT TERM
1336 f572 8d 9d              [ 7 ] EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
1337 f574 27 32              [ 3 ]         BEQ     CNVRTS          ; RETURN IF VALID NUMBER
1338 f576 16 fb fa           [ 5 ] BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
1339                               
1340                               *********************************************
1341                               * BUILD BINARY VALUE USING INPUT CHARACTERS.
1342                               * INPUT: A=ASCII HEX VALUE OR DELIMITER
1343                               * SP+0=RETURN ADDRESS
1344                               * SP+2=16 BIT RESULT AREA
1345                               * OUTPUT: Z=1 A=BINARY VALUE
1346                               * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
1347                               * VOLATILE: D
1348                               ****************************************
1349 f579 0f 9b              [ 6 ] BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
1350 f57b 0f 9c              [ 6 ]         CLR     <NUMBER+1       ; CLEAR NUMBER
1351 f57d 8d 2a              [ 7 ] BLDHEX  BSR     READ            ; GET INPUT CHARACTER
1352 f57f 8d 11              [ 7 ] BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
1353 f581 26 25              [ 3 ]         BNE     CNVRTS          ; RETURN IF NOT A NUMBER
1354 f583 c6 10              [ 2 ]         LDB     #16             ; PREPARE SHIFT
1355 f585 3d                 [11 ]         MUL                     ; BY FOUR PLACES
1356 f586 86 04              [ 2 ]         LDA     #4              ; ROTATE BINARY INTO VALUE
1357 f588 58                 [ 2 ] BLDSHF  ASLB                    ; OBTAIN NEXT BIT
1358 f589 09 9c              [ 6 ]         ROL     <NUMBER+1       ; INTO LOW BYTE
1359 f58b 09 9b              [ 6 ]         ROL     <NUMBER         ; INTO HI BYTE
1360 f58d 4a                 [ 2 ]         DECA                    ; COUNT DOWN
1361 f58e 26 f8              [ 3 ]         BNE     BLDSHF          ; BRANCH IF MORE TO DO
1362 f590 20 14              [ 3 ]         BRA     CNVOK           ; SET GOOD RETURN CODE
1363                               
1364                               ****************************************
1365                               * CONVERT ASCII CHARACTER TO BINARY BYTE
1366                               * INPUT: A=ASCII
1367                               * OUTPUT: Z=1 A=BINARY VALUE
1368                               * Z=0 IF INVALID
1369                               * ALL REGISTERS TRANSPARENT
1370                               * (A UNALTERED IF INVALID HEX)
1371                               **************************************
1372 f592 81 30              [ 2 ] CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
1373 f594 25 12              [ 3 ]         BLO     CNVRTS          ; BRANCH NOT VALUE
1374 f596 81 39              [ 2 ]         CMPA    #'9             ; ? POSSIBLE A-F
1375 f598 2f 0a              [ 3 ]         BLE     CNVGOT          ; BRANCH NO TO ACCEPT
1376 f59a 81 41              [ 2 ]         CMPA    #'A             ; ? LESS THEN TEN
1377 f59c 25 0a              [ 3 ]         BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
1378 f59e 81 46              [ 2 ]         CMPA    #'F             ; ? NOT TOO LARGE
1379 f5a0 22 06              [ 3 ]         BHI     CNVRTS          ; NO, RETURN TOO LARGE
1380 f5a2 80 07              [ 2 ]         SUBA    #7              ; DOWN TO BINARY
1381 f5a4 84 0f              [ 2 ] CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
1382 f5a6 1a 04              [ 3 ] CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
1383 f5a8 39                 [ 5 ] CNVRTS  RTS                     ; RETURN TO CALLER
1384                               
1385                               * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
1386 f5a9 3f                 [19 ] READ     SWI                    ; GET NEXT CHARACTER
1387 f5aa 00                                FCB    INCHNP          ; FUNCTION
1388 f5ab 81 18              [ 2 ]          CMPA   #CAN            ; ? ABORT COMMAND
1389 f5ad 27 c7              [ 3 ]          BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
1390 f5af 39                 [ 5 ]          RTS                    ; RETURN TO CALLER
1391                               *G
1392                               
1393                               ***************GO - START PROGRAM EXECUTION
1394 f5b0 8d 01              [ 7 ] CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
1395 f5b2 3b                 [15 ]          RTI                    ; START EXECUTING
1396                               
1397                               * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
1398                               * BREAKPOINTS.
1399 f5b3 35 30              [ 9 ] GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
1400 f5b5 34 10              [ 7 ]          PSHS   X               ; STORE RETURN BACK
1401 f5b7 26 19              [ 3 ]          BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
1402                               
1403                               * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
1404                               * IMMEDIATE BREAKPOINT.
1405 f5b9 17 01 b6           [ 9 ]          LBSR   CBKLDR          ; SEARCH BREAKPOINTS
1406 f5bc ae 6c              [ 6 ]          LDX    12,S            ; LOAD PROGRAM COUNTER
1407 f5be 5a                 [ 2 ] ARMBLP  DECB                    ; COUNT DOWN
1408 f5bf 2b 16              [ 3 ]         BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
1409 f5c1 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
1410 f5c3 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
1411 f5c5 26 f7              [ 3 ]         BNE     ARMBLP          ; LOOP IF NOT
1412 f5c7 81 3f              [ 2 ]         CMPA    #$3F            ; ? SWI BREAKPOINTED
1413 f5c9 26 02              [ 3 ]         BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
1414 f5cb 97 fb              [ 4 ]         STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
1415 f5cd 0c 8f              [ 6 ] ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
1416 f5cf 16 01 06           [ 5 ]         LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
1417                               
1418                               * OBTAIN NEW PROGRAM COUNTER
1419 f5d2 17 00 bb           [ 9 ] GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
1420 f5d5 ed 6c              [ 6 ]         STD     12,S            ; STORE INTO STACK
1421 f5d7 17 01 98           [ 9 ] ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
1422 f5da 00 fa              [ 6 ]         NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
1423 f5dc 5a                 [ 2 ] ARMLOP  DECB                    ; ? DONE
1424 f5dd 2b c9              [ 3 ]         BMI     CNVRTS          ; RETURN WHEN DONE
1425 f5df a6 b4              [ 7 ]         LDA     [,Y]            ; LOAD OPCODE
1426 f5e1 a7 30              [ 5 ]         STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
1427 f5e3 86 3f              [ 2 ]         LDA     #$3F            ; READY "SWI" OPCODE
1428 f5e5 a7 b1              [10 ]         STA     [,Y++]          ; STORE AND MOVE UP TABLE
1429 f5e7 20 f3              [ 3 ]         BRA     ARMLOP          ; AND CONTINUE
1430                               
1431                               *******************CALL - CALL ADDRESS AS SUBROUTINE
1432 f5e9 8d c8              [ 7 ] CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
1433 f5eb 35 7f              [15 ]         PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
1434 f5ed ad f1              [13 ]         JSR     [,S++]          ; CALL USER SUBROUTINE
1435 f5ef 3f                 [19 ] CGOBRK  SWI                     ; PERFORM BREAKPOINT
1436 f5f0 0a                               FCB     BRKPT           ; FUNCTION
1437 f5f1 20 fc              [ 3 ]         BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
1438                               
1439                               ****************MEMORY - DISPLAY/CHANGE MEMORY
1440                               * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
1441                               * THE COMMAND HANDLER FOR QUICK COMMANDS
1442 f5f3 17 00 9a           [ 9 ] CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
1443 f5f6 dd 9e              [ 5 ] CMEMN   STD     <ADDR           ; STORE DEFAULT
1444 f5f8 9e 9e              [ 5 ] CMEM2   LDX     <ADDR           ; LOAD POINTER
1445 f5fa 17 fb f7           [ 9 ]         LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
1446 f5fd 86 2d              [ 2 ]         LDA     #'-             ; LOAD DELIMITER
1447 f5ff 3f                 [19 ]         SWI                     ; SEND OUT
1448 f600 01                               FCB     OUTCH           ; FUNCTION
1449 f601 17 ff 0b           [ 9 ] CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
1450 f604 27 0a              [ 3 ]         BEQ     CMENUM          ; BRANCH IF NUMBER
1451                               * COMA - SKIP BYTE
1452 f606 81 2c              [ 2 ]         CMPA    #',             ; ? COMMA
1453 f608 26 0e              [ 3 ]         BNE     CMNOTC          ; BRANCH NOT
1454 f60a 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1455 f60c 30 01              [ 5 ]         LEAX    1,X             ; TO NEXT BYTE
1456 f60e 20 f1              [ 3 ]         BRA     CMEM4           ; AND INPUT IT
1457 f610 d6 9c              [ 4 ] CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
1458 f612 8d 47              [ 7 ]         BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
1459 f614 81 2c              [ 2 ]         CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
1460 f616 27 e9              [ 3 ]         BEQ     CMEM4           ; BRANCH YES
1461                               * QUOTED STRING
1462 f618 81 27              [ 2 ] CMNOTC  CMPA    #$27            ; ? QUOTED STRING
1463 f61a 26 0c              [ 3 ]         BNE     CMNOTQ          ; BRANCH NO
1464 f61c 8d 8b              [ 7 ] CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
1465 f61e 81 27              [ 2 ]         CMPA    #$27            ; ? END OF QUOTED STRING
1466 f620 27 0c              [ 3 ]         BEQ     CMSPCE          ; YES, QUIT STRING MODE
1467 f622 1f 89              [ 6 ]         TFR     A,B             ; TO B FOR SUBROUTINE
1468 f624 8d 35              [ 7 ]         BSR     MUPDAT          ; GO UPDATE BYTE
1469 f626 20 f4              [ 3 ]         BRA     CMESTR          ; GET NEXT CHARACTER
1470                               * BLANK - NEXT BYTE
1471 f628 81 20              [ 2 ] CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
1472 f62a 26 06              [ 3 ]         BNE     CMNOTB          ; BRANCH NOT
1473 f62c 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1474 f62e 3f                 [19 ] CMSPCE  SWI                     ; GIVE SPACE
1475 f62f 07                               FCB     SPACE           ; FUNCTION
1476 f630 20 c6              [ 3 ]         BRA     CMEM2           ; NOW PROMPT FOR NEXT
1477                               
1478                               * LINE FEED - NEXT BYTE WITH ADDRESS
1479 f632 81 0a              [ 2 ] CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
1480 f634 26 08              [ 3 ]         BNE     CMNOTL          ; BRANCH NO
1481 f636 86 0d              [ 2 ]         LDA     #CR             ; GIVE CARRIAGE RETURN
1482 f638 3f                 [19 ]         SWI                     ; TO CONSOLE
1483 f639 01                               FCB     OUTCH           ; HANDLER
1484 f63a 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEXT ADDRESS
1485 f63c 20 0a              [ 3 ]         BRA     CMPADP          ; BRANCH TO SHOW
1486                               
1487                               * UP ARROW - PREVIOUS BYTE AND ADDRESS
1488 f63e 81 5e              [ 2 ] CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
1489 f640 26 0a              [ 3 ]         BNE     CMNOTU          ; BRANCH NOT
1490 f642 30 1e              [ 5 ]         LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
1491 f644 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER
1492 f646 3f                 [19 ] CMPADS  SWI                     ; FORCE NEW LINE
1493 f647 06                               FCB     PCRLF           ; FUNCTION
1494 f648 8d 07              [ 7 ] CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
1495 f64a 20 ac              [ 3 ]         BRA     CMEM2           ; THEN PROMPT FOR INPUT
1496                               
1497                               * SLASH - NEXT BYTE WITH ADDRESS
1498 f64c 81 2f              [ 2 ] CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
1499 f64e 27 f6              [ 3 ]         BEQ     CMPADS          ; YES, SEND ADDRESS
1500 f650 39                 [ 5 ]         RTS                     ; RETURN FROM COMMAND
1501                               
1502                               * PRINT CURRENT ADDRESS
1503 f651 9e 9e              [ 5 ] PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
1504 f653 34 10              [ 7 ]         PSHS    X               ; SAVE X ON STACK
1505 f655 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT FOR DISPLAY
1506 f657 3f                 [19 ]         SWI                     ; DISPLAY POINTER IN HEX
1507 f658 05                               FCB     OUT4HS          ; FUNCTION
1508 f659 35 90              [ 9 ]         PULS    PC,X            ; RECOVER POINTER AND RETURN
1509                               
1510                               * UPDATE BYTE
1511 f65b 9e 9e              [ 5 ] MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
1512 f65d e7 80              [ 6 ]         STB     ,X+             ; STORE AND INCREMENT X
1513 f65f e1 1f              [ 5 ]         CMPB    -1,X            ; ? SUCCESFULL STORE
1514 f661 26 03              [ 3 ]         BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
1515 f663 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER VALUE
1516 f665 39                 [ 5 ]         RTS                     ; BACK TO CALLER
1517 f666 34 02              [ 6 ] MUPBAD  PSHS    A               ; SAVE A REGISTER
1518 f668 86 3f              [ 2 ]         LDA     #'?             ; SHOW INVALID
1519 f66a 3f                 [19 ]         SWI                     ; SEND OUT
1520 f66b 01                               FCB     OUTCH           ; FUNCTION
1521 f66c 35 82              [ 8 ]         PULS    PC,A            ; RETURN TO CALLER
1522                               
1523                               ********************WINDOW - SET WINDOW VALUE
1524 f66e 8d 20              [ 7 ] CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
1525 f670 dd a0              [ 5 ]         STD     <WINDOW         ; STORE IT IN
1526 f672 39                 [ 5 ]         RTS                     ; END COMMAND
1527                               
1528                               ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
1529 f673 8d 1b              [ 7 ] CDISP   BSR     CDNUM           ; FETCH ADDRESS
1530 f675 c4 f0              [ 2 ]         ANDB    #$F0            ; FORCE TO 16 BOUNDARY
1531 f677 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1532 f679 30 2f              [ 5 ]         LEAX    15,Y            ; DEFAULT LENGTH
1533 f67b 25 04              [ 3 ]         BCS     CDISPS          ; BRANCH IF END OF INPUT
1534 f67d 8d 11              [ 7 ]         BSR     CDNUM           ; OBTAIN COUNT
1535 f67f 30 ab              [ 8 ]         LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
1536 f681 34 30              [ 9 ] CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
1537 f683 10 a3 62           [ 8 ]         CMPD    2,S             ; ? WAS IT COUNT
1538 f686 23 02              [ 3 ]         BLS     CDCNT           ; BRANCH YES
1539 f688 ed e4              [ 5 ]         STD     ,S              ; STORE HIGH ADDRESS
1540 f68a ad 9d f1 54        [15 ] CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
1541 f68e 35 e0              [11 ]         PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
1542                               
1543                               * OBTAIN NUMBER - ABORT IF NONE
1544                               * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
1545                               * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
1546                               * ELSE C=0
1547 f690 17 fe 7e           [ 9 ] CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
1548 f693 26 09              [ 3 ]         BNE     CDBADN          ; BRANCH IF INVALID
1549 f695 81 2f              [ 2 ]         CMPA    #'/             ; ? VALID DELIMITER
1550 f697 22 05              [ 3 ]         BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
1551 f699 81 0e              [ 2 ]         CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
1552 f69b dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER
1553 f69d 39                 [ 5 ]         RTS                     ; RETURN WITH COMPARE
1554 f69e 16 fa d2           [ 5 ] CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
1555                               
1556                               *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
1557 f6a1 8d ed              [ 7 ] CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
1558 f6a3 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1559 f6a5 8d e9              [ 7 ]         BSR     CDNUM           ; OBTAIN END ADDRESS
1560 f6a7 6f e2              [ 8 ]         CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
1561 f6a9 34 26              [ 9 ]         PSHS    Y,D             ; STORE VALUES ON STACK
1562 f6ab ad 9d f1 35        [15 ] CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
1563 f6af ad 9d f1 33        [15 ]         JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
1564 f6b3 34 01              [ 6 ]         PSHS    CC              ; SAVE RETURN CODE
1565 f6b5 ad 9d f1 2f        [15 ]         JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
1566 f6b9 35 01              [ 6 ]         PULS    CC              ; OBTAIN CONDITION CODE SAVED
1567 f6bb 26 e1              [ 3 ]         BNE     CDBADN          ; BRANCH IF ERROR
1568 f6bd 35 b2              [12 ]         PULS    PC,Y,X,A        ; RETURN FROM COMMAND
1569                               
1570                               *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
1571 f6bf 8d 01              [ 7 ] CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
1572 f6c1 01                               FCB     1               ; LOAD FUNCTION CODE FOR PACKET
1573                               
1574 f6c2 33 f1              [10 ] CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
1575 f6c4 33 d4              [ 7 ]         LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
1576 f6c6 27 03              [ 3 ]         BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
1577 f6c8 8d c6              [ 7 ]         BSR     CDNUM           ; OBTAIN OFFSET
1578 f6ca 8c                               FCB     SKIP2           ; SKIP DEFAULT OFFSET
1579 f6cb 4f                 [ 2 ] CLVDFT  CLRA                    ; CREATE ZERO OFFSET
1580 f6cc 5f                 [ 2 ]         CLRB                    ; AS DEFAULT
1581 f6cd 34 4e              [10 ]         PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
1582 f6cf 20 da              [ 3 ]         BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
1583                               
1584                               ******************VERIFY - COMPARE MEMORY WITH FILES
1585 f6d1 8d ef              [ 7 ] CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
1586 f6d3 ff                               FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
1587                               
1588                               *******************TRACE - TRACE INSTRUCTIONS
1589                               ******************* . - SINGLE STEP TRACE
1590 f6d4 8d ba              [ 7 ] CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
1591 f6d6 dd 91              [ 5 ]         STD     <TRACEC         ; STORE COUNT
1592 f6d8 32 62              [ 5 ] CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
1593 f6da ee f8 0a           [ 9 ] CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
1594 f6dd df 99              [ 5 ]         STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
1595 f6df de f6              [ 5 ]         LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
1596 f6e1 cc 07 01           [ 3 ]         LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
1597 f6e4 ed 42              [ 6 ]         STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
1598 f6e6 3b                 [15 ]         RTI                     ; RETURN FOR ONE INSTRUCTION
1599                               
1600                               *************NULLS  -  SET NEW LINE AND CHAR PADDING
1601 f6e7 8d a7              [ 7 ] CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
1602 f6e9 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; RESET VALUES
1603 f6eb 39                 [ 5 ]         RTS                     ; END COMMAND
1604                               
1605                               ******************STLEVEL - SET STACK TRACE LEVEL
1606 f6ec 27 05              [ 3 ] CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
1607 f6ee 8d a0              [ 7 ]         BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
1608 f6f0 dd f8              [ 5 ]         STD     <SLEVEL         ; STORE NEW ENTRY
1609 f6f2 39                 [ 5 ]         RTS                     ; TO COMMAND HANDLER
1610 f6f3 30 6e              [ 5 ] STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
1611 f6f5 9f f8              [ 5 ]         STX     <SLEVEL         ; AND STORE IT
1612 f6f7 39                 [ 5 ]         RTS                     ; END COMMAND
1613                               
1614                               ******************OFFSET - COMPUTE SHORT AND LONG
1615                               ******************                  BRANCH OFFSETS
1616 f6f8 8d 96              [ 7 ] COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
1617 f6fa 1f 01              [ 6 ]         TFR     D,X             ; USE AS FROM ADDRESS
1618 f6fc 8d 92              [ 7 ]         BSR     CDNUM           ; OBTAIN TO ADDRESS
1619                               * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
1620 f6fe 30 01              [ 5 ]         LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
1621 f700 34 30              [ 9 ]         PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
1622 f702 a3 e4              [ 6 ]         SUBD    ,S              ; FIND OFFSET
1623 f704 ed e4              [ 5 ]         STD     ,S              ; SAVE OVER STACK
1624 f706 30 61              [ 5 ]         LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
1625 f708 1d                 [ 2 ]         SEX                     ; SIGN EXTEND LOW BYTE
1626 f709 a1 e4              [ 4 ]         CMPA    ,S              ; ? VALID ONE BYTE OFFSET
1627 f70b 26 02              [ 3 ]         BNE     COFNO1          ; BRANCH IF NOT
1628 f70d 3f                 [19 ]         SWI                     ; SHOW ONE BYTE OFFSET
1629 f70e 04                               FCB     OUT2HS          ; FUNCTION
1630 f70f ee e4              [ 5 ] COFNO1  LDU     ,S              ; RELOAD OFFSET
1631 f711 33 5f              [ 5 ]         LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
1632 f713 ef 84              [ 5 ]         STU     ,X              ; STORE BACK WHERE X POINTS NOW
1633 f715 3f                 [19 ]         SWI                     ; SHOW TWO BYTE OFFSET
1634 f716 05                               FCB     OUT4HS          ; FUNCTION
1635 f717 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1636 f718 06                               FCB     PCRLF           ; FUNCTION
1637 f719 35 96              [11 ]         PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
1638                               *H
1639                               
1640                               *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
1641                               *************             BREAKPOINTS
1642 f71b 27 23              [ 3 ] CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
1643 f71d 17 fd f1           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
1644 f720 27 2c              [ 3 ]         BEQ     CBKADD          ; BRANCH TO ADD IF SO
1645 f722 81 2d              [ 2 ]         CMPA    #'-             ; ? CORRECT DELIMITER
1646 f724 26 3f              [ 3 ]         BNE     CBKERR          ; NO, BRANCH FOR ERROR
1647 f726 17 fd e8           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
1648 f729 27 03              [ 3 ]         BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
1649 f72b 0f fa              [ 6 ]         CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
1650 f72d 39                 [ 5 ] CBKRTS  RTS                     ; END COMMAND
1651                               * DELETE THE ENTRY
1652 f72e 8d 40              [ 7 ] CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
1653 f730 5a                 [ 2 ] CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
1654 f731 2b 32              [ 3 ]         BMI     CBKERR          ; BRANCH NO, ERROR
1655 f733 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS THE ENTRY
1656 f735 26 f9              [ 3 ]         BNE     CBKDLP          ; NO, TRY NEXT
1657                               * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
1658 f737 ae a1              [ 8 ] CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
1659 f739 af 3c              [ 6 ]         STX     -4,Y            ; MOVE DOWN BY ONE
1660 f73b 5a                 [ 2 ]         DECB                    ; ? DONE
1661 f73c 2a f9              [ 3 ]         BPL     CBKDLM          ; NO, CONTINUE MOVE
1662 f73e 0a fa              [ 6 ]         DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
1663 f740 8d 2e              [ 7 ] CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
1664 f742 27 e9              [ 3 ]         BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
1665 f744 30 a1              [ 7 ] CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
1666 f746 3f                 [19 ]         SWI                     ; DISPLAY IN HEX
1667 f747 05                               FCB     OUT4HS          ; FUNCTION
1668 f748 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1669 f749 26 f9              [ 3 ]         BNE     CBKDSL          ; LOOP IF NGABLE RAM
1670 f74b 3f                 [19 ]         SWI                     ; SKIP TO NEW LINK
1671 f74c 06                               FCB     PCRLF           ; FUNCTIONRTS
1672 f74d 39                 [ 5 ]         RTS
1673                               
1674                               * ADD NEW ENTRY
1675 f74e 8d 20              [ 7 ] CBKADD  BSR     CBKSET          ; SETUP REGISTERS
1676 f750 c1 08              [ 2 ]         CMPB    #NUMBKP         ; ? ALREADY FULL
1677 f752 27 11              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1678 f754 a6 84              [ 4 ]         LDA     ,X              ; LOAD BYTE TO TRAP
1679 f756 e7 84              [ 4 ]         STB     ,X              ; TRY TO CHANGE
1680 f758 e1 84              [ 4 ]         CMPB    ,X              ; ? CHANGEABLE RAM
1681 f75a 26 09              [ 3 ]         BNE     CBKERR          ; BRANCH ERROR IF NOT
1682 f75c a7 84              [ 4 ]         STA ,X                  ; RESTORE BYTE
1683 f75e 5a                 [ 2 ] CBKADL  DECB                    ; COUNT DOWN
1684 f75f 2b 07              [ 3 ]         BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
1685 f761 ac a1              [ 9 ]         CMPX    ,Y++            ; ? ENTRY ALREADY HERE
1686 f763 26 f9              [ 3 ]         BNE     CBKADL          ; LOOP IF NOT
1687 f765 16 fa 0b           [ 5 ] CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
1688 f768 af a4              [ 5 ] CBKADT  STX ,Y                  ; ADD THIS ENTRY
1689 f76a 6f 31              [ 7 ]         CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
1690 f76c 0c fa              [ 6 ]         INC     <BKPTCT         ; ADD ONE TO COUNT
1691 f76e 20 d0              [ 3 ]         BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
1692                               * SETUP REGISTERS FOR SCAN
1693 f770 9e 9b              [ 5 ] CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
1694 f772 31 8d f0 3c        [ 9 ] CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
1695 f776 d6 fa              [ 4 ]         LDB     <BKPTCT         ; LOAD ENTRY COUNT
1696 f778 39                 [ 5 ]         RTS                     ; RETURN
1697                               
1698                               *****************ENCODE  -  ENCODE A POSTBYTE
1699 f779 6f e2              [ 8 ] CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
1700 f77b 5f                 [ 2 ]         CLRB                    ; ZERO POSTBYTE VALUE
1701 f77c 30 8c 3f           [ 5 ]         LEAX    <CONV1,PCR      ; START TABLE SEARCH
1702 f77f 3f                 [19 ]         SWI                     ; OBTAIN FIRST CHARACTER
1703 f780 00                               FCB     INCHNP          ; FUNCTION
1704 f781 81 5b              [ 2 ]         CMPA    #'[             ; ? INDIRECT HERE
1705 f783 26 06              [ 3 ]         BNE     CEN2            ; BRANCH IF NOT
1706 f785 86 10              [ 2 ]         LDA     #$10            ; SET INDIRECT BIT ON
1707 f787 a7 e4              [ 4 ]         STA     ,S              ; SAVE FOR LATER
1708 f789 3f                 [19 ] CENGET  SWI                     ; OBTAIN NEXT CHARACTER
1709 f78a 00                               FCB     INCHNP          ; FUNCTION
1710 f78b 81 0d              [ 2 ] CEN2    CMPA    #CR             ; ? END OF ENTRY
1711 f78d 27 0c              [ 3 ]         BEQ     CEND1           ; BRANCH YES
1712 f78f 6d 84              [ 6 ] CENLP1  TST     ,X              ; ? END OF TABLE
1713 f791 2b d2              [ 3 ]         BMI     CBKERR          ; BRANCH ERROR IF SO
1714 f793 a1 81              [ 7 ]         CMPA    ,X++            ; ? THIS THE CHARACTER
1715 f795 26 f8              [ 3 ]         BNE     CENLP1          ; BRANCH IF NOT
1716 f797 eb 1f              [ 5 ]         ADDB    -1,X            ; ADD THIS VALUE
1717 f799 20 ee              [ 3 ]         BRA     CENGET          ; GET NEXT INPUT
1718 f79b 30 8c 49           [ 5 ] CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
1719 f79e 1f 98              [ 6 ]         TFR     B,A             ; SAVE COPY IN A
1720 f7a0 84 60              [ 2 ]         ANDA    #$60            ; ISOLATE REGISTER MASK
1721 f7a2 aa e4              [ 4 ]         ORA     ,S              ; ADD IN INDIRECTION BIT
1722 f7a4 a7 e4              [ 4 ]         STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
1723 f7a6 c4 9f              [ 2 ]         ANDB    #$9F            ; CLEAR REGISTER BITS
1724 f7a8 6d 84              [ 6 ] CENLP2  TST     ,X              ; ? END OF TABLE
1725 f7aa 27 b9              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1726 f7ac e1 81              [ 7 ]         CMPB    ,X++            ; ? SAME VALUE
1727 f7ae 26 f8              [ 3 ]         BNE     CENLP2          ; LOOP IF NOT
1728 f7b0 e6 1f              [ 5 ]         LDB     -1,X            ; LOAD RESULT VALUE
1729 f7b2 ea e4              [ 4 ]         ORB     ,S              ; ADD TO BASE SKELETON
1730 f7b4 e7 e4              [ 4 ]         STB     ,S              ; SAVE POSTBYTE ON STACK
1731 f7b6 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT
1732 f7b8 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
1733 f7b9 04                               FCB     OUT2HS          ; FUNCTION
1734 f7ba 3f                 [19 ]         SWI                     ; TO NEXT LINE
1735 f7bb 06                               FCB     PCRLF           ; FUNCTION
1736 f7bc 35 84              [ 8 ]         PULS    PC,B            ; END OF COMMAND
1737                               
1738                               * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
1739                               CONV1
1740 f7be 41 04 42 05 44 06                FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
1741 f7c6 48 01 48 01 48 00                FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
1742 f7ce 2d 09 2d 01 53 70                FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
1743 f7d6 55 50 58 10 2b 07                FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
1744 f7de 50 80 43 00 52 00                FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
1745 f7e6 ff                               FCB     $FF             ; END OF TABLE
1746                               
1747                               * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
1748                               * BIT SKELETON.
1749                               CONV2
1750 f7e7 10 84 11 00                      FDB     $1084,$1100     ; R,      H,R
1751 f7eb 12 88 13 89                      FDB     $1288,$1389     ; HH,R    HHHH,R
1752 f7ef 14 86 15 85                      FDB     $1486,$1585     ; A,R     B,R
1753 f7f3 16 8b 17 80                      FDB     $168B,$1780     ; D,R     ,R+
1754 f7f7 18 81 19 82                      FDB     $1881,$1982     ; ,R++    ,-R
1755 f7fb 1a 83 82 8c                      FDB     $1A83,$828C     ; ,--R    HH,PCR
1756 f7ff 83 8d 03 9f                      FDB     $838D,$039F     ; HHHH,PCR [HHHH]
1757 f803 00                               FCB     0               ; END OF TABLE
1758                               
1759                               
1760                               *******************************************************
1761                               * FLEX LOADER
1762                               *******************************************************
1763                               
1764                               
1765 c100                          XLOADER  EQU $C100
1766                               
1767 f804 bd f8 15           [ 8 ] FLEX    JSR XINIT
1768                                   
1769 f807 bd f8 56           [ 8 ]         JSR XRESTORE
1770                               
1771 f80a 8e c1 00           [ 3 ]         LDX #XLOADER
1772 f80d 86 01              [ 2 ]         LDA #1
1773 f80f bd f8 29           [ 8 ]         JSR XREAD    
1774                               
1775 f812 7e c1 00           [ 4 ]         JMP XLOADER
1776                               
1777                               
1778 0002                          DRQ     EQU 2       ; DRQ BIT MASK
1779 0001                          BUSY    EQU 1       ; BUSY MASK
1780 001c                          RDMSK   EQU $1C     ; READ ERROR MASK
1781                               
1782 e818                          COMREG  EQU $E818   ; COMMMAND REGISTER
1783 e819                          TRKREG  EQU $E819   ; TRACK REGISTER
1784 e81a                          SECREG  EQU $E81A   ; SECTOR REGISTER
1785 e81b                          DATREG  EQU $E81B   ; DATA REGISTER
1786 008c                          RDCMND  EQU $8C     ; READ COMMAND
1787 0008                          RSCMND  EQU $08     ; RESTORE COMMAND
1788                                
1789                               
1790                                   ; INIT AND WARM
1791                                   ;
1792                                   ; DRIVER INITIALIZATION
1793                               
1794                               
1795 f815 4f                 [ 2 ] XINIT   CLRA            ; select PIA control register
1796 f816 b7 e8 11           [ 5 ]         STA CRA
1797 f819 86 0f              [ 2 ]         LDA #$0F        ; PORTA b0..b3 = output
1798 f81b b7 e8 10           [ 5 ]         STA DDRA        
1799 f81e 86 3c              [ 2 ]         LDA #%00111100  ; select PIA output register
1800 f820 b7 e8 11           [ 5 ]         STA CRA
1801 f823 86 09              [ 2 ]         LDA #%00001001  ; b3=1 (FM)
1802                                                       ; b2=0 (side 0)
1803                                                       ; b1-0 = 01 ( drive 1 select)
1804 f825 b7 e8 10           [ 5 ]         STA PRA
1805                                    
1806 f828 39                 [ 5 ]         RTS         
1807                               
1808                                   ; READ
1809                                   ;
1810                                   ; READ ONE SECTOR
1811                                   ;
1812                                   ; ENTRY -   (X) = Address in memory where sector is to be placed.
1813                                   ;           (A) = Track Number
1814                                   ; EXIT -    (X) May be destroyed
1815                                   ;           (A) May be destroyed
1816                                   ;           (B) = Error condition
1817                                   ;           (Z) = 1 if no error
1818                                   ;               = 0 if an erro
1819                               
1820 f829 86 8c              [ 2 ] XREAD   LDA #RDCMND     ; SETUP READ SECTOR COMMAND
1821 f82b b7 e8 18           [ 5 ]         STA COMREG      ; ISSUE READ COMMAND 
1822 f82e 17 00 32           [ 9 ]         LBSR XDEL28      ; DELAY 
1823 f831 5f                 [ 2 ]         CLRB            ; GET SECTOR LENGTH (=256) 
1824 f832 b6 e8 18           [ 5 ] XREAD3   LDA COMREG      ; GET WD STATUS 
1825 f835 85 02              [ 2 ]         BITA #DRQ       ; CHECK FOR DATA 
1826 f837 26 08              [ 3 ]         BNE XREAD5       ; BRANCH IF DATA PRESENT 
1827 f839 85 01              [ 2 ]         BITA #BUSY      ; CHECK IF BUSY 
1828 f83b 26 f5              [ 3 ]         BNE XREAD3       ; LOOP IF SO 
1829 f83d 1f 89              [ 6 ]         TFR A,B         ; ERROR IF NOT 
1830 f83f 20 0a              [ 3 ]         BRA XREAD6 
1831 f841 b6 e8 1b           [ 5 ] XREAD5   LDA DATREG      ; GET DATA BYTE 
1832 f844 a7 80              [ 6 ]         STA 0,X+        ; PUT IN MEMORY 
1833 f846 5a                 [ 2 ]         DECB            ; DEC THE COUNTER 
1834 f847 26 e9              [ 3 ]         BNE XREAD3       ; LOOP TIL DONE 
1835 f849 8d 03              [ 7 ]         BSR XWAIT        ; WAIT TIL WD IS FINISHED 
1836 f84b c5 1c              [ 2 ] XREAD6   BITB #RDMSK     ; MASK ERRORS 
1837 f84d 39                 [ 5 ]         RTS             ; RETURN
1838                                
1839                                   ; WAIT
1840                                   ;
1841                                   ; WAIT FOR 1771 TO FINISH COMMAND
1842                               
1843 f84e f6 e8 18           [ 5 ] XWAIT    LDB COMREG      ; GET WD STATUS 
1844 f851 c5 01              [ 2 ]         BITB #BUSY      ; CHECK IF BUSY 
1845 f853 26 f9              [ 3 ]         BNE XWAIT        ; LOOP TIL NOT BUSY 
1846 f855 39                 [ 5 ]         RTS             ; RETURN
1847                               
1848                                   ; RESTORE
1849                               
1850 f856 86 08              [ 2 ] XRESTORE LDA #RSCMND     ; SETUP RESTORE COMMAND 
1851 f858 b7 e8 18           [ 5 ]         STA COMREG      ; ISSUE RESTORE COMMAND 
1852 f85b 8d 06              [ 7 ]         BSR XDEL28       ; DELAY 
1853 f85d 17 ff ee           [ 9 ]         LBSR XWAIT       ; WAIT TIL WD IS FINISHED 
1854 f860 c5 d8              [ 2 ]         BITB #$D8       ; CHECK FOR ERROR 
1855 f862 39                 [ 5 ]         RTS             ; RETURN
1856                                
1857                                   ; DELAY
1858                               
1859 f863 17 00 00           [ 9 ] XDEL28   LBSR XDEL14 
1860 f866 17 00 00           [ 9 ] XDEL14   LBSR XDEL 
1861 f869 39                 [ 5 ] XDEL     RTS
1862                               
1863                               
1864                               ****************************************************
1865                               *            DEFAULT INTERRUPT TRANSFERS           *
1866                               ****************************************************
1867 f86a 6e 9d ef 58        [11 ] RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
1868 f86e 6e 9d ef 56        [11 ] SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
1869 f872 6e 9d ef 54        [11 ] SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
1870 f876 6e 9d ef 52        [11 ] FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
1871 f87a 6e 9d ef 50        [11 ] IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
1872 f87e 6e 9d ef 4e        [11 ] SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
1873 f882 6e 9d ef 4c        [11 ] NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
1874                               
1875                               ******************************************************
1876                               *            ASSIST09 HARDWARE VECTOR TABLE
1877                               * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
1878                               * THE MC6809 HARDWARE VECTORS.
1879                               ******************************************************
1880 fff0                                  ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
1881 fff0 f8 6a                            FDB     RSRVD           ; RESERVED SLOT
1882 fff2 f8 6e                            FDB     SWI3            ; SOFTWARE INTERRUPT 3
1883 fff4 f8 72                            FDB     SWI2            ; SOFTWARE INTERRUPT 2
1884 fff6 f8 76                            FDB     FIRQ            ; FAST INTERRUPT REQUEST
1885 fff8 f8 7a                            FDB     IRQ             ; INTERRUPT REQUEST
1886 fffa f8 7e                            FDB     SWI             ; SOFTWARE INTERRUPT
1887 fffc f8 82                            FDB     NMI             ; NON-MASKABLE INTERRUPT
1888 fffe f0 37                            FDB     RESET           ; RESTART
1889                               
1890                               
