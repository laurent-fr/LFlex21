0001                               *************************************
0002                               * COPYRIGHT (C) MOTOROLA, INC. 1979 *
0003                               *************************************
0004                               
0005                               *************************************
0006                               * THIS IS THE BASE ASSIST09 ROM.
0007                               * IT MAY RUN WITH OR WITHOUT THE
0008                               * EXTENSION ROM WHICH
0009                               * WHEN PRESENT WILL BE AUTOMATICALLY
0010                               * INCORPORATED BY THE BLDVTR
0011                               * SUBROUTINE.
0012                               *************************************
0013                               
0014                               *********************************************
0015                               * GLOBAL MODULE EQUATES
0016                               ********************************************
0017 f000                          ROMBEG  EQU     $F000           ; ROM START ASSEMBLY ADDRESS
0018 fffff700                          RAMOFS  EQU     -$900          ; ROM OFFSET TO RAM WORK PAGE
0019 1000                          ROMSIZ  EQU     4096            ; ROM SIZE
0020 e000                          ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
0021 e808                          ACIA    EQU     $E808           ; DEFAULT ACIA ADDRESS
0022 e800                          PTM     EQU     $E800           ; DEFAULT PTM ADDRESS
0023 0000                          DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
0024 0005                          DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
0025 003e                          PROMPT  EQU     '>              ; PROMPT CHARACTER
0026 0008                          NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
0027                               *********************************************
0028                               
0029                               *********************************************
0030                               * MISCELANEOUS EQUATES
0031                               *********************************************
0032 0004                          EOT     EQU     $04             ; END OF TRANSMISSION
0033 0007                          BELL    EQU     $07             ; BELL CHARACTER
0034 000a                          LF      EQU     $0A             ; LINE FEED
0035 000d                          CR      EQU     $0D             ; CARRIAGE RETURN
0036 0010                          DLE     EQU     $10             ; DATA LINK ESCAPE
0037 0018                          CAN     EQU     $18             ; CANCEL (CTL-X)
0038                               
0039                               * PTM ACCESS DEFINITIONS
0040 e801                          PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
0041 e800                          PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
0042 e801                          PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
0043 e802                          PTMTM1  EQU     PTM+2           ; LATCH 1
0044 e804                          PTMTM2  EQU     PTM+4           ; LATCH 2
0045 e806                          PTMTM3  EQU     PTM+6           ; LATCH 3
0046 008c                          SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
0047                               
0048                               *******************************************
0049                               * ASSIST09 MONITOR SWI FUNCTIONS
0050                               * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
0051                               * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
0052                               ******************************************
0053 0000                          INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
0054 0001                          OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
0055 0002                          PDATA1  EQU     2               ; OUTPUT STRING
0056 0003                          PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
0057 0004                          OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
0058 0005                          OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
0059 0006                          PCRLF   EQU     6               ; OUTPUT CR/LF
0060 0007                          SPACE   EQU     7               ; OUTPUT A SPACE
0061 0008                          MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
0062 0009                          VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
0063 000a                          BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
0064 000b                          PAUSE   EQU     11              ; TASK PAUSE FUNCTION
0065 000b                          NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
0066                               
0067                               * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
0068                               * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
0069                               * RELATIVE POSITIONING MUST BE MAINTAINED
0070                               
0071 0000                          .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
0072 0002                          .CMDL1  EQU     2               ; FIRST COMMAND LIST
0073 0004                          .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
0074 0006                          .SWI3   EQU     6               ; SWI3 ROUTINE
0075 0008                          .SWI2   EQU     8               ; SWI2 ROUTINE
0076 000a                          .FIRQ   EQU     10              ; FIRQ ROUTINE
0077 000c                          .IRQ    EQU     12              ; IRQ ROUTINE
0078 000e                          .SWI    EQU     14              ; SWI ROUTINE
0079 0010                          .NMI    EQU     16              ; NMI ROUTINE
0080 0012                          .RESET  EQU     18              ; RESET ROUTINE
0081 0014                          .CION   EQU     20              ; CONSOLE ON
0082 0016                          .CIDTA  EQU     22              ; CONSOLE INPUT DATA
0083 0018                          .CIOFF  EQU     24              ; CONSOLE INPUT OFF
0084 001a                          .COON   EQU     26              ; CONSOLE OUTPUT ON
0085 001c                          .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
0086 001e                          .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
0087 0020                          .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
0088 0022                          .BSON   EQU     34              ; PUNCH/LOAD ON
0089 0024                          .BSDTA  EQU     36              ; PUNCH/LOAD DATA
0090 0026                          .BSOFF  EQU     38              ; PUNCH/LOAD OFF
0091 0028                          .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
0092 002a                          .EXPAN  EQU     42              ; EXPRESSION ANALYZER
0093 002c                          .CMDL2  EQU     44              ; SECOND COMMAND LIST
0094 002e                          .ACIA   EQU     46              ; ACIA ADDRESS
0095 0030                          .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
0096 0032                          .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
0097 0034                          .PTM    EQU     52              ; PTM ADDRESS
0098 001b                          NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
0099 0034                          HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
0100                               
0101                               ******************************************
0102                               *           WORK AREA
0103                               * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
0104                               * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
0105                               * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
0106                               * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
0107                               * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
0108                               * DEFINED HEREIN.
0109                               ******************************************
0110 e700                          WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
0111                               *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
0112 e800                                  ORG     WORKPG+256      ; READY PAGE DEFINITIONS
0113                               
0114                               * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
0115                               * FOR PROPER INITIALIZATION
0116 e7fc                                  ORG     *-4
0117 e7fc                          PAUSER  EQU     *               ; PAUSE ROUTINE
0118 e7fb                                  ORG     *-1
0119 e7fb                          SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
0120 e7fa                                  ORG     *-1
0121 e7fa                          BKPTCT  EQU     *               ; BREAKPOINT COUNT
0122 e7f8                                  ORG     *-2             ; SLEVEL EQU
0123 e7f8                          SLEVEL  EQU     *               ; STACK TRACE LEVEL
0124 e7c2                                  ORG     -NUMVTR*2+*
0125 e7c2                          VECTAB  EQU     *               ; VECTOR TABLE
0126 e7b2                                  ORG     -2*NUMBKP+*
0127 e7b2                          BKPTBL  EQU     *               ; BREAKPOINT TABLE
0128 e7a2                                  ORG     -2*NUMBKP+*
0129 e7a2                          BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
0130 e7a0                                  ORG     *-2
0131 e7a0                          WINDOW  EQU     *               ; WINDOW
0132 e79e                                  ORG     *-2
0133 e79e                          ADDR    EQU     *               ; ADDRESS POINTER VALUE
0134 e79d                                  ORG     *-1
0135 e79d                          BASEPG  EQU     *               ; BASE PAGE VALUE
0136 e79b                                  ORG     *-2
0137 e79b                          NUMBER  EQU     *               ; BINARY BUILD AREA
0138 e799                                  ORG     *-2
0139 e799                          LASTOP  EQU     *               ; LAST OPCODE TRACED
0140 e797                                  ORG     *-2
0141 e797                          RSTACK  EQU     *               ; RESET STACK POINTER
0142 e795                                  ORG     *-2
0143 e795                          PSTACK  EQU     *               ; COMMAND RECOVERY STACK
0144 e793                                  ORG     *-2
0145 e793                          PCNTER  EQU     *               ; LAST PROGRAM COUNTER
0146 e791                                  ORG     *-2
0147 e791                          TRACEC  EQU     *               ; TRACE COUNT
0148 e790                                  ORG     *-1
0149 e790                          SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
0150 e78f                                  ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
0151 e78f                          MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
0152 e78e                                  ORG     *-1
0153 e78e                          DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
0154 e766                                  ORG     *-40
0155 e766                          ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
0156 e751                                  ORG     *-21
0157 e751                          TSTACK  EQU     *               ; TEMPORARY STACK HOLD
0158 e751                          STACK   EQU     *               ; START OF INITIAL STACK
0159                               
0160                               ******************************************
0161                               * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
0162                               * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
0163                               * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
0164                               * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
0165                               * FROM THE ROM BEGINNING ADDRESS.
0166                               ********************************************
0167 e000                          	ORG	$E000
0168 e000 00                       	FCB	0
0169                               
0170 f000                                  ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
0171                               
0172                               *****************************************************
0173                               * BLDVTR - BUILD ASSIST09 VECTOR TABLE
0174                               * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
0175                               * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
0176                               * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
0177                               * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
0178                               * ASSIST09 EXECUTION.
0179                               * INPUT: S->VALID STACK RAM
0180                               * OUTPUT: U->VECTOR TABLE ADDRESS
0181                               * DPR->ASSIST09 WORK AREA PAGE
0182                               * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
0183                               * ALL REGISTERS VOLATILE
0184                               *************************************************
0185 f000 30 8d f7 be        [ 9 ] BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
0186 f004 1f 10              [ 6 ]         TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
0187 f006 1f 8b              [ 6 ]         TFR     A,DP            ; SETUP DPR
0188 f008 97 9d              [ 4 ]         STA     <BASEPG         ; STORE FOR QUICK REFERENCE
0189 f00a 33 84              [ 4 ]         LEAU    ,X              ; RETURN TABLE TO CALLER
0190 f00c 31 8c 35           [ 5 ]         LEAY    <INITVT,PCR     ; LOAD FROM ADDR
0191 f00f ef 81              [ 8 ]         STU     ,X++            ; INIT VECTOR TABLE ADDRESS
0192 f011 c6 16              [ 2 ]         LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
0193 f013 34 04              [ 6 ]         PSHS    B               ; STORE INDEX ON STACK
0194 f015 1f 20              [ 6 ] BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
0195 f017 e3 a1              [ 9 ]         ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
0196 f019 ed 81              [ 8 ]         STD     ,X++            ; INTO VECTOR TABLE
0197 f01b 6a e4              [ 6 ]         DEC     ,S              ; COUNT DOWN
0198 f01d 26 f6              [ 3 ]         BNE     BLD2            ; BRANCH IF MORE TO INSERT
0199 f01f c6 0d              [ 2 ]         LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
0200 f021 a6 a0              [ 6 ] BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
0201 f023 a7 80              [ 6 ]         STA     ,X+             ; STORE INTO POSITION
0202 f025 5a                 [ 2 ]         DECB                    ; COUNT DOWN
0203 f026 26 f9              [ 3 ]         BNE     BLD3            ; LOOP UNTIL DONE
0204 f028 31 8d ef d4        [ 9 ]         LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
0205 f02c 8e 20 fe           [ 3 ]         LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
0206 f02f ac a1              [ 9 ]         CMPX    ,Y++            ; ? EXTENDED ROM HERE
0207 f031 26 02              [ 3 ]         BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
0208 f033 ad a4              [ 7 ]         JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
0209 f035 35 84              [ 8 ] BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
0210                               
0211                               *****************************************************
0212                               *                RESET ENTRY POINT
0213                               * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
0214                               * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
0215                               * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
0216                               * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
0217                               * CALL.
0218                               *******************************************************
0219 f037 32 8d f7 16        [ 9 ] RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
0220 f03b 8d c3              [ 7 ]         BSR     BLDVTR          ; BUILD VECTOR TABLE
0221 f03d 4f                 [ 2 ] RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
0222 f03e 1f 8b              [ 6 ]         TFR     A,DP            ; DEFAULT TO PAGE ZERO
0223 f040 3f                 [19 ]         SWI                     ; PERFORM MONITOR FIREUP
0224 f041 08                               FCB     MONITR          ; TO ENTER COMMAND PROCESSING
0225 f042 20 f9              [ 3 ]         BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
0226                               
0227                               ******************************************************
0228                               *        INITVT - INITIAL VECTOR TABLE
0229                               * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
0230                               * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
0231                               * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
0232                               * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
0233                               * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
0234                               ************************************************
0235 f044 01 56                    INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
0236 f046 02 94                            FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
0237 f048 02 92                            FDB     SWI3R-*         ; DEFAULT SWI3
0238 f04a 02 90                            FDB     SWI2R-*         ; DEFAULT SWI2
0239 f04c 02 72                            FDB     FIRQR-*         ; DEFAULT FIRQ
0240 f04e 02 8c                            FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
0241 f050 00 45                            FDB     SWIR-*          ; DEFAULT SWI ROUTINE
0242 f052 02 2d                            FDB     NMIR-*          ; DEFAULT NMI ROUTINE
0243 f054 ff e3                            FDB     RESET-*         ; RESTART VECTOR
0244 f056 02 92                            FDB     CION-*          ; DEFAULT CION
0245 f058 02 86                            FDB     CIDTA-*         ; DEFAULT CIDTA
0246 f05a 02 a6                            FDB     CIOFF-*         ; DEFAULT CIOFF
0247 f05c 02 8c                            FDB     COON-*          ; DEFAULT COON
0248 f05e 02 a3                            FDB     CODTA-*         ; DEFAULT CODTA
0249 f060 02 a0                            FDB     COOFF-*         ; DEFAULT COOFF
0250 f062 03 aa                            FDB     HSDTA-*         ; DEFAULT HSDTA
0251 f064 02 c7                            FDB     BSON-*          ; DEFAULT BSON
0252 f066 02 e2                            FDB     BSDTA-*         ; DEFAULT BSDTA
0253 f068 02 cf                            FDB     BSOFF-*         ; DEFAULT BSOFF
0254 f06a f7 92                            FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
0255 f06c 04 8d                            FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
0256 f06e 01 2b                            FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
0257                               * CONSTANTS
0258 f070 e8 08                    INTVS   FDB     ACIA            ; DEFAULT ACIA
0259 f072 00 05                            FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
0260 f074 00 00                            FDB     0               ; DEFAULT ECHO
0261 f076 e8 00                            FDB     PTM             ; DEFAULT PTM
0262 f078 00 00                            FDB     0               ; INITIAL STACK TRACE LEVEL
0263 f07a 00                               FCB     0               ; INITIAL BREAKPOINT COUNT
0264 f07b 00                               FCB     0               ; SWI BREAKPOINT LEVEL
0265 f07c 39                               FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
0266 f07d                          INTVE   EQU     *
0267                               *B
0268                               ***********************************************
0269                               *            ASSIST09 SWI HANDLER
0270                               * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
0271                               * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
0272                               * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
0273                               * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
0274                               * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
0275                               * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
0276                               * INPUT: MACHINE STATE DEFINED FOR SWI
0277                               * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
0278                               * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
0279                               * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
0280                               * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
0281                               ************************************************
0282                               * SWI FUNCTION VECTOR TABLE
0283 f07d 01 96                    SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
0284 f07f 01 b3                            FDB     ZOTCH1-SWIVTB   ; OUTCH
0285 f081 01 cd                            FDB     ZPDTA1-SWIVTB   ; PDATA1
0286 f083 01 c5                            FDB     ZPDATA-SWIVTB   ; PDATA
0287 f085 01 77                            FDB     ZOT2HS-SWIVTB   ; OUT2HS
0288 f087 01 75                            FDB     ZOT4HS-SWIVTB   ; OUT4HS
0289 f089 01 c2                            FDB     ZPCRLF-SWIVTB   ; PCRLF
0290 f08b 01 7b                            FDB     ZSPACE-SWIVTB   ; SPACE
0291 f08d 00 55                            FDB     ZMONTR-SWIVTB   ; MONITR
0292 f08f 01 7f                            FDB     ZVSWTH-SWIVTB   ; VCTRSW
0293 f091 02 58                            FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
0294 f093 01 d3                            FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
0295                               
0296 f095 6a 8d f6 f7        [11 ] SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
0297 f099 17 02 27           [ 9 ]         LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
0298                               * CHECK FOR BREAKPOINT TRAP
0299 f09c ee 6a              [ 6 ]         LDU     10,S            ; LOAD PROGRAM COUNTER
0300 f09e 33 5f              [ 5 ]         LEAU    -1,U            ; BACK TO SWI ADDRESS
0301 f0a0 0d fb              [ 6 ]         TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
0302 f0a2 26 11              [ 3 ]         BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
0303 f0a4 17 06 ab           [ 9 ]         LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0304 f0a7 50                 [ 2 ]         NEGB                    ; OBTAIN POSITIVE COUNT
0305 f0a8 5a                 [ 2 ] SWILP   DECB                    ; COUNT DOWN
0306 f0a9 2b 0a              [ 3 ]         BMI     SWIDNE          ; BRANCH WHEN DONE
0307 f0ab 11 a3 a1           [10 ]         CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
0308 f0ae 26 f8              [ 3 ]         BNE     SWILP           ; BRANCH IF NOT
0309 f0b0 ef 6a              [ 6 ]         STU     10,S            ; SET PROGRAM COUNTER BACK
0310 f0b2 16 02 20           [ 5 ]         LBRA    ZBKPNT          ; GO DO BREAKPOINT
0311 f0b5 0f fb              [ 6 ] SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
0312 f0b7 37 06              [ 7 ]         PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
0313 f0b9 c1 0b              [ 2 ]         CMPB    #NUMFUN         ; ? TOO HIGH
0314 f0bb 10 22 02 11        [ 6 ]         LBHI    ERROR           ; YES, DO BREAKPOINT
0315 f0bf ef 6a              [ 6 ]         STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
0316 f0c1 58                 [ 2 ]         ASLB                    ; FUNCTION CODE TIMES TWO
0317 f0c2 33 8c b8           [ 5 ]         LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
0318 f0c5 ec c5              [ 6 ]         LDD     B,U             ; LOAD OFFSET
0319 f0c7 6e cb              [ 7 ]         JMP     D,U             ; JUMP TO ROUTINE
0320                               
0321                               **********************************************
0322                               * REGISTERS TO FUNCTION ROUTINES:
0323                               *  DP-> WORK AREA PAGE
0324                               *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
0325                               *  S=AS FROM SWI INTERRUPT
0326                               *********************************************
0327                               
0328                               **************************************************
0329                               *            [SWI FUNCTION 8]
0330                               *              MONITOR ENTRY
0331                               *  FIREUP THE ASSIST09 MONITOR.
0332                               *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
0333                               *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
0334                               *   1) INITIALIZE CONSOLE I/O
0335                               *   2) OPTIONALLY PRINT SIGNON
0336                               *   3) INITIALIZE PTM FOR SINGLE STEPPING
0337                               *   4) ENTER COMMAND PROCESSOR
0338                               * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
0339                               *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
0340                               *************************************************
0341                               
0342 f0c9 41 53 53 49 53 54        SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
0343 f0d1 04                               FCB     EOT
0344 f0d2 10 df 97           [ 6 ] ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
0345 f0d5 6d 61              [ 7 ]         TST     1,S             ; ? INIT CONSOLE AND SEND MSG
0346 f0d7 26 0d              [ 3 ]         BNE     ZMONT2          ; BRANCH IF NOT
0347 f0d9 ad 9d f6 f9        [15 ]         JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
0348 f0dd ad 9d f6 fb        [15 ]         JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
0349 f0e1 30 8c e5           [ 5 ]         LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
0350 f0e4 3f                 [19 ]         SWI                     ; PERFORM
0351 f0e5 03                               FCB     PDATA           ; PRINT STRING
0352 f0e6 9e f6              [ 5 ] ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
0353 f0e8 27 0b              [ 3 ]         BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
0354 f0ea 6f 02              [ 7 ]         CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
0355 f0ec 6f 03              [ 7 ]         CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
0356 f0ee cc 93 a6           [ 3 ]         LDD     #$93A6          ; SETUP TIMER 1 MODE
0357 f0f1 a7 01              [ 5 ]         STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
0358 f0f3 e7 84              [ 4 ]         STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
0359                               * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
0360                                       ;CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
0361                               * FALL INTO COMMAND PROCESSOR
0362                               
0363                               ***************************************************
0364                               *          COMMAND HANDLER
0365                               *  BREAKPOINTS ARE REMOVED AT THIS TIME.
0366                               *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
0367                               *  UNTIL A SEPARATOR ON THE STACK.
0368                               *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
0369                               *  CALL IT OR GIVE '?' RESPONSE.
0370                               *  DURING COMMAND SEARCH:
0371                               *      B=OFFSET TO NEXT ENTRY ON X
0372                               *      U=SAVED S
0373                               *      U-1=ENTRY SIZE+2
0374                               *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
0375                               *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
0376                               *      U-4=START OF COMMAND STORE
0377                               *      S+0=END OF COMMAND STORE
0378                               ***********************************************
0379                               
0380 f0f5 3f                 [19 ] CMD     SWI                     ; TO NEW LINE
0381 f0f6 06                               FCB     PCRLF           ; FUNCTION
0382                               * DISARM THE BREAKPOINTS
0383 f0f7 17 06 58           [ 9 ] CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
0384 f0fa 2a 0c              [ 3 ]         BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
0385 f0fc 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
0386 f0fd d7 fa              [ 4 ]         STB     <BKPTCT         ; FLAG AS DISARMED
0387 f0ff 5a                 [ 2 ] CMDDDL  DECB                    ; ? FINISHED
0388 f100 2b 06              [ 3 ]         BMI     CMDNOL          ; BRANCH IF SO
0389 f102 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
0390 f104 a7 b1              [10 ]         STA     [,Y++]          ; STORE BACK OVER "SWI"
0391 f106 20 f7              [ 3 ]         BRA     CMDDDL          ; LOOP UNTIL DONE
0392 f108 ae 6a              [ 6 ] CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
0393 f10a 9f 93              [ 5 ]         STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
0394 f10c 86 3e              [ 2 ]         LDA     #PROMPT         ; LOAD PROMPT CHARACTER
0395 f10e 3f                 [19 ]         SWI                     ; SEND TO OUTPUT HANDLER
0396 f10f 01                               FCB     OUTCH           ; FUNCTION
0397 f110 33 e4              [ 4 ]         LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
0398 f112 df 95              [ 5 ]         STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
0399 f114 4f                 [ 2 ]         CLRA                    ; PREPARE ZERO
0400 f115 5f                 [ 2 ]         CLRB                    ; PREPARE ZERO
0401 f116 dd 9b              [ 5 ]         STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
0402 f118 dd 8f              [ 5 ]         STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
0403 f11a dd 91              [ 5 ]         STD     <TRACEC         ; CLEAR TRACE COUNT
0404 f11c c6 02              [ 2 ]         LDB     #2              ; SET D TO TWO
0405 f11e 34 07              [ 8 ]         PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
0406                               * CHECK FOR "QUICK" COMMANDS.
0407 f120 17 04 66           [ 9 ]         LBSR    READ            ; OBTAIN FIRST CHARACTER
0408 f123 30 8d 05 93        [ 9 ]         LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
0409 f127 81 2e              [ 2 ]         CMPA    #'.             ; ? QUICK TRACE
0410 f129 27 5a              [ 3 ]         BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
0411 f12b 30 8d 04 fb        [ 9 ]         LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
0412 f12f 81 2f              [ 2 ]         CMPA    #'/             ; ? OPEN LAST USED MEMORY
0413 f131 27 52              [ 3 ]         BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
0414                               * PROCESS NEXT CHARACTER
0415 f133 81 20              [ 2 ] CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
0416 f135 23 14              [ 3 ]         BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
0417 f137 34 02              [ 6 ]         PSHS   A                ; BUILD ONTO STACK
0418 f139 6c 5f              [ 7 ]         INC    -1,U             ; COUNT THIS CHARACTER
0419 f13b 81 2f              [ 2 ]         CMPA   #'/              ; ? MEMORY COMMAND
0420 f13d 27 4f              [ 3 ]         BEQ    CMDMEM           ; BRANCH IF SO
0421 f13f 17 04 1d           [ 9 ]         LBSR   BLDHXC           ; TREAT AS HEX VALUE
0422 f142 27 02              [ 3 ]         BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
0423 f144 6a 5e              [ 7 ]         DEC    -2,U             ; FLAG AS INVALID NUMBER
0424 f146 17 04 40           [ 9 ] CMD3    LBSR   READ             ; OBTAIN NEXT CHARACTER
0425 f149 20 e8              [ 3 ]         BRA    CMD2             ; TEST NEXT CHARACTER
0426                               * GOT COMMAND, NOW SEARCH TABLES
0427 f14b 80 0d              [ 2 ] CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
0428 f14d a7 5d              [ 5 ]         STA    -3,U             ; SETUP FLAG
0429 f14f 9e c4              [ 5 ]         LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
0430 f151 e6 80              [ 6 ] CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
0431 f153 2a 10              [ 3 ]         BPL    CMDSME           ; BRANCH IF NOT LIST END
0432 f155 9e ee              [ 5 ]         LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
0433 f157 5c                 [ 2 ]         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
0434 f158 27 f7              [ 3 ]         BEQ     CMDSCH          ; BRANCH IF SO
0435 f15a 10 de 95           [ 6 ] CMDBAD  LDS     <PSTACK         ; RESTORE STACK
0436 f15d 30 8d 01 5e        [ 9 ]         LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
0437 f161 3f                 [19 ]         SWI                     ; SEND OUT
0438 f162 02                               FCB     PDATA1          ; TO CONSOLE
0439 f163 20 90              [ 3 ]         BRA     CMD             ; AND TRY AGAIN
0440                               * SEARCH NEXT ENTRY
0441 f165 5a                 [ 2 ] CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
0442 f166 e1 5f              [ 5 ]         CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
0443 f168 24 03              [ 3 ]         BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
0444 f16a 3a                 [ 3 ] CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
0445 f16b 20 e4              [ 3 ]         BRA     CMDSCH          ; AND TRY NEXT
0446 f16d 31 5d              [ 5 ] CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
0447 f16f a6 5f              [ 5 ]         LDA     -1,U            ; LOAD SIZE+2
0448 f171 80 02              [ 2 ]         SUBA    #2              ; TO ACTUAL SIZE ENTERED
0449 f173 a7 5e              [ 5 ]         STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
0450 f175 5a                 [ 2 ] CMDCMP  DECB                    ; DOWN ONE BYTE
0451 f176 a6 80              [ 6 ]         LDA     ,X+             ; NEXT COMMAND CHARACTER
0452 f178 a1 a2              [ 6 ]         CMPA    ,-Y             ; ? SAME AS THAT ENTERED
0453 f17a 26 ee              [ 3 ]         BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
0454 f17c 6a 5e              [ 7 ]         DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
0455 f17e 26 f5              [ 3 ]         BNE     CMDCMP          ; BRANCH IF MORE TO TEST
0456 f180 3a                 [ 3 ]         ABX                     ; TO NEXT ENTRY
0457 f181 ec 1e              [ 6 ]         LDD     -2,X            ; LOAD OFFSET
0458 f183 30 8b              [ 8 ]         LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
0459 f185 6d 5d              [ 7 ] CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
0460 f187 32 c4              [ 4 ]         LEAS    ,U              ; DELETE STACK WORK AREA
0461 f189 ad 1e              [ 8 ]         JSR     -2,X            ; CALL COMMAND
0462 f18b 16 ff 7a           [ 5 ]         LBRA    CMDNOL          ; GO GET NEXT COMMAND
0463 f18e 6d 5e              [ 7 ] CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
0464 f190 2b c8              [ 3 ]         BMI     CMDBAD          ; BRANCH ERROR IF NOT
0465 f192 30 88 ae           [ 5 ]         LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
0466 f195 dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER ENTERED
0467 f197 20 ec              [ 3 ]         BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
0468                               
0469                               ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
0470                               **    DPR->ASSIST09 DIRECT PAGE WORK AREA
0471                               **    Z=1 CARRIAGE RETURN ENTERED
0472                               **    Z=0 NON CARRIAGE RETURN DELIMITER
0473                               **    S=NORMAL RETURN ADDRESS
0474                               ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
0475                               ** AN ERROR FLAG (*).
0476                               **************************************************
0477                               *       ASSIST09 COMMAND TABLES
0478                               * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
0479                               * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
0480                               * THESE BY USING THE VECTOR SWAP FUNCTION.
0481                               *
0482                               * ENTRY FORMAT:
0483                               *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
0484                               *    +1...COMMAND STRING
0485                               *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
0486                               *
0487                               * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
0488                               * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
0489                               *        SECOND COMMAND TABLE.
0490                               * THE -2 TERMINATES COMMAND SEARCHES.
0491                               *****************************************************
0492                               
0493                               * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
0494                               * LIST ENTRY.
0495                               
0496 f199 fe                       CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
0497                               
0498                               * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
0499                               * LIST ENTRY.
0500                               
0501 f19a                          CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
0502 f19a 04                               FCB     4
0503 f19b 42                               FCC     /B/             ; 'BREAKPOINT' COMMAND
0504 f19c 05 5f                            FDB     CBKPT-*
0505 f19e 04                               FCB     4
0506 f19f 43                               FCC     /C/             ; 'CALL' COMMAND
0507 f1a0 04 29                            FDB     CCALL-*
0508 f1a2 04                               FCB     4
0509 f1a3 44                               FCC     /D/             ; 'DISPLAY' COMMAND
0510 f1a4 04 af                            FDB     CDISP-*
0511 f1a6 04                               FCB     4
0512 f1a7 45                               FCC     /E/             ; 'ENCODE' COMMAND
0513 f1a8 05 b1                            FDB     CENCDE-*
0514 f1aa 04                               FCB     4
0515 f1ab 46                               FCC     /F/             ; 'FLEX' COMMAND
0516 f1ac 06 38                            FDB     FLEX-*
0517 f1ae 04                               FCB     4
0518 f1af 47                               FCC     /G/             ; 'GO' COMMAND
0519 f1b0 03 e0                            FDB     CGO-*
0520 f1b2 04                               FCB     4
0521 f1b3 4c                               FCC     /L/             ; 'LOAD' COMMAND
0522 f1b4 04 eb                            FDB     CLOAD-*
0523 f1b6 04                               FCB     4
0524 f1b7 4d                               FCC     /M/             ; 'MEMORY' COMMAND
0525 f1b8 04 1b                            FDB     CMEM-*
0526 f1ba 04                               FCB     4
0527 f1bb 4e                               FCC     /N/             ; 'NULLS' COMMAND
0528 f1bc 05 0b                            FDB     CNULLS-*
0529 f1be 04                               FCB     4
0530 f1bf 4f                               FCC     /O/             ; 'OFFSET' COMMAND
0531 f1c0 05 18                            FDB     COFFS-*
0532 f1c2 04                               FCB     4
0533 f1c3 50                               FCC     /P/             ; 'PUNCH' COMMAND
0534 f1c4 04 bd                            FDB     CPUNCH-*
0535 f1c6 04                               FCB     4
0536 f1c7 52                               FCC     /R/             ; 'REGISTERS' COMMAND
0537 f1c8 02 92                            FDB     CREG-*
0538 f1ca 04                               FCB     4
0539 f1cb 53                               FCC     /S/             ; 'STLEVEL' COMMAND
0540 f1cc 05 00                            FDB     CSTLEV-*
0541 f1ce 04                               FCB     4
0542 f1cf 54                               FCC     /T/             ; 'TRACE' COMMAND
0543 f1d0 04 e4                            FDB     CTRACE-*
0544 f1d2 04                               FCB     4
0545 f1d3 56                               FCC     /V/             ; 'VERIFY' COMMAND
0546 f1d4 04 dd                            FDB     CVER-*
0547 f1d6 04                               FCB     4
0548 f1d7 57                               FCC     /W/             ; 'WINDOW' COMMAND
0549 f1d8 04 76                            FDB     CWINDO-*
0550 f1da ff                               FCB     -1              ; END, CONTINUE WITH THE SECOND
0551                               
0552                               *************************************************
0553                               *             [SWI FUNCTIONS 4 AND 5]
0554                               *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
0555                               *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
0556                               * INPUT: X->BYTE OR WORD TO DECODE
0557                               * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
0558                               *         X->NEXT BYTE OR WORD
0559                               *************************************************
0560 f1db a6 80              [ 6 ] ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
0561 f1dd 34 06              [ 7 ]         PSHS    D               ; SAVE - DO NOT REREAD
0562 f1df c6 10              [ 2 ]         LDB     #16             ; SHIFT BY 4 BITS
0563 f1e1 3d                 [11 ]         MUL                     ; WITH MULTIPLY
0564 f1e2 8d 04              [ 7 ]         BSR     ZOUTHX          ; SEND OUT AS HEX
0565 f1e4 35 06              [ 7 ]         PULS    D               ; RESTORE BYTES
0566 f1e6 84 0f              [ 2 ]         ANDA    #$0F            ; ISOLATE RIGHT HEX
0567 f1e8 8b 90              [ 2 ] ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
0568 f1ea 19                 [ 2 ]         DAA                     ; ADJUST
0569 f1eb 89 40              [ 2 ]         ADCA    #$40            ; PREPARE CHARACTER BITS
0570 f1ed 19                 [ 2 ]         DAA                     ; ADJUST
0571 f1ee 6e 9d f5 ec        [11 ] SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
0572                               
0573 f1f2 8d e7              [ 7 ] ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
0574 f1f4 8d e5              [ 7 ] ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
0575 f1f6 af 64              [ 6 ]         STX     4,S             ; UPDATE USERS X REGISTER
0576                               * FALL INTO SPACE ROUTINE
0577                               
0578                               *************************************************
0579                               *            [SWI FUNCTION 7]
0580                               *         SPACE - SEND BLANK TO OUTPUT HANDLER
0581                               * INPUT: NONE
0582                               * OUTPUT: BLANK SEND TO CONSOLE HANDLER
0583                               *************************************************
0584 f1f8 86 20              [ 2 ] ZSPACE  LDA     #'              ; LOAD BLANK
0585 f1fa 20 3d              [ 3 ]         BRA     ZOTCH2          ; SEND AND RETURN
0586                               
0587                               ***********************************************
0588                               *             [SWI FUNCTION 9]
0589                               *          SWAP VECTOR TABLE ENTRY
0590                               * INPUT: A=VECTOR TABLE CODE (OFFSET)
0591                               * X=0 OR REPLACEMENT VALUE
0592                               * OUTPUT: X=PREVIOUS VALUE
0593                               ***********************************************
0594 f1fc a6 61              [ 5 ] ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
0595 f1fe 81 34              [ 2 ]         CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
0596 f200 22 39              [ 3 ]         BHI     ZOTCH3          ; IGNORE CALL IF SO
0597 f202 10 9e c2           [ 6 ]         LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
0598 f205 ee a6              [ 6 ]         LDU     A,Y             ; U=OLD ENTRY
0599 f207 ef 64              [ 6 ]         STU     4,S             ; RETURN OLD VALUE TO CALLERS X
0600 f209 af 7e              [ 6 ]         STX     -2,S            ; ? X=0
0601 f20b 27 2e              [ 3 ]         BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
0602 f20d af a6              [ 6 ]         STX     A,Y             ; REPLACE ENTRY
0603 f20f 20 2a              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM SWI
0604                               *D
0605                               
0606                               ************************************************
0607                               *               [SWI FUNCTION 0]
0608                               *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
0609                               * NULLS AND RUBOUTS ARE IGNORED.
0610                               * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
0611                               * CARRIAGE RETURN.
0612                               * UNLESS WE ARE LOADING FROM TAPE.
0613                               ************************************************
0614 f211 8d 5d              [ 7 ] ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
0615 f213 8d 5f              [ 7 ] ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
0616 f215 24 fa              [ 3 ]         BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
0617 f217 4d                 [ 2 ]         TSTA                    ; ? TEST FOR NULL
0618 f218 27 f9              [ 3 ]         BEQ     ZINCH           ; IGNORE NULL
0619 f21a 81 7f              [ 2 ]         CMPA    #$7F            ; ? RUBOUT
0620 f21c 27 f5              [ 3 ]         BEQ     ZINCH           ; BRANCH YES TO IGNORE
0621 f21e a7 61              [ 5 ]         STA     1,S             ; STORE INTO CALLERS A
0622 f220 0d 8f              [ 6 ]         TST     <MISFLG         ; ? LOAD IN PROGRESS
0623 f222 26 17              [ 3 ]         BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
0624 f224 81 0d              [ 2 ]         CMPA    #CR             ; ? CARRIAGE RETURN
0625 f226 26 04              [ 3 ]         BNE     ZIN2            ; NO, TEST ECHO BYTE
0626 f228 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0627 f22a 8d c2              [ 7 ]         BSR     SEND            ; ALWAYS ECHO LINE FEED
0628 f22c 0d f4              [ 6 ] ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
0629 f22e 26 0b              [ 3 ]         BNE     ZOTCH3          ; NO, RETURN
0630                               * FALL THROUGH TO OUTCH
0631                               ************************************************
0632                               *            [SWI FUNCTION 1]
0633                               *        OUTCH - OUTPUT CHARACTER FROM A
0634                               * INPUT: NONE
0635                               * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
0636                               * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
0637                               ************************************************
0638 f230 a6 61              [ 5 ] ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
0639 f232 30 8c 09           [ 5 ]         LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
0640 f235 81 0a              [ 2 ]         CMPA    #LF             ; ? LINE FEED
0641 f237 27 0f              [ 3 ]         BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
0642 f239 8d b3              [ 7 ] ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
0643 f23b 0c 90              [ 6 ] ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
0644 f23d 3b                 [15 ]         RTI                     ; RETURN FROM "SWI" FUNCTION
0645                               
0646                               **************************************************
0647                               * [SWI FUNCTION 6]
0648                               * PCRLF - SEND CR/LF TO CONSOLE HANDLER
0649                               * INPUT: NONE
0650                               * OUTPUT: CR AND LF SENT TO HANDLER
0651                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0652                               **************************************************
0653 f23e 04                       ZPCRLS  FCB     EOT             ; NULL STRING
0654 f23f 30 8c fc           [ 5 ] ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
0655                               * FALL INTO CR/LF CODE
0656                               
0657                               **************************************************
0658                               * [SWI FUNCTION 3]
0659                               * PDATA - OUTPUT CR/LF AND STRING
0660                               * INPUT: X->STRING
0661                               * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
0662                               * HANDLER.
0663                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0664                               * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
0665                               * PROPER PUNCH DATA.
0666                               **************************************************
0667                               
0668 f242 86 0d              [ 2 ] ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
0669 f244 8d a8              [ 7 ]         BSR     SEND            ; SEND IT
0670 f246 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
0671                               * FALL INTO PDATA1
0672                               
0673                               *************************************************
0674                               * [SWI FUNCTION 2]
0675                               * PDATA1 - OUTPUT STRING TILL EOT ($04)
0676                               * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
0677                               * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
0678                               * SECOND IS RECEIVED.
0679                               * INPUT: X->STRING
0680                               * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
0681                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
0682                               *************************************************
0683                               
0684 f248 8d a4              [ 7 ] ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
0685 f24a a6 80              [ 6 ] ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
0686 f24c 81 04              [ 2 ]         CMPA    #EOT            ; ? EOT
0687 f24e 26 f8              [ 3 ]         BNE     ZPDTLP          ; LOOP IF NOT
0688                               * FALL INTO PAUSE CHECK FUNCTION
0689                               
0690                               ********************************************
0691                               * [SWI FUNCTION 12]
0692                               * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
0693                               * FOR FREEZE CONDITION OR CTL-X BREAK
0694                               * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
0695                               * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
0696                               * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
0697                               * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
0698                               * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
0699                               * HANDLER.
0700                               * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
0701                               ******************************************
0702                               
0703 f250 8d 1e              [ 7 ] ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
0704 f252 8d 06              [ 7 ]         BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
0705 f254 1f a9              [ 6 ]         TFR     CC,B            ; PREPARE TO REPLACE CC
0706 f256 e7 e4              [ 4 ]         STB     ,S              ; OVERLAY OLD ONE ON STACK
0707 f258 20 e1              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM "SWI"
0708                               
0709                               * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
0710                               * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
0711                               * VOLATILE: U,X,D
0712 f25a 8d 18              [ 7 ] CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
0713 f25c 24 05              [ 3 ]         BCC     CHKRTN          ; BRANCH NO TO RETURN
0714 f25e 81 18              [ 2 ]         CMPA    #CAN            ; ? CTL-X FOR ABORT
0715 f260 26 02              [ 3 ]         BNE     CHKWT           ; BRANCH NO TO PAUSE
0716 f262 53                 [ 2 ] CHKSEC  COMB                    ; SET CARRY
0717 f263 39                 [ 5 ] CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
0718 f264 8d 0a              [ 7 ] CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
0719 f266 8d 0c              [ 7 ]         BSR     XQCIDT          ; ? KEY FOR START
0720 f268 24 fa              [ 3 ]         BCC     CHKWT           ; LOOP UNTIL RECEIVED
0721 f26a 81 18              [ 2 ]         CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
0722 f26c 27 f4              [ 3 ]         BEQ     CHKSEC          ; BRANCH YES
0723 f26e 4f                 [ 2 ]         CLRA                    ; SET C=0 FOR NO ABORT
0724 f26f 39                 [ 5 ]         RTS                     ; AND RETURN
0725                               
0726                               * SAVE MEMORY WITH JUMPS
0727 f270 6e 9d f5 76        [11 ] XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
0728 f274 ad 9d f5 60        [15 ] XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
0729 f278 84 7f              [ 2 ]         ANDA  #$7F              ; STRIP PARITY
0730 f27a 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0731                               
0732                               ********************************************
0733                               * NMI DEFAULT INTERRUPT HANDLER
0734                               * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
0735                               * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
0736                               * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
0737                               * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
0738                               * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
0739                               *********************************************
0740                               
0741 f27b 4f 50 2d 04              MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
0742                               
0743 f27f 8d 42              [ 7 ] NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
0744 f281 0d 8f              [ 6 ]         TST     <MISFLG         ; ? THRU A BREAKPOINT
0745 f283 26 34              [ 3 ]         BNE     NMICON          ; BRANCH IF SO TO CONTINUE
0746 f285 0d 90              [ 6 ]         TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
0747 f287 2b 29              [ 3 ]         BMI     NMITRC          ; BRANCH YES
0748 f289 30 6c              [ 5 ]         LEAX    12,S            ; OBTAIN USERS STACK POINTER
0749 f28b 9c f8              [ 6 ]         CMPX    <SLEVEL         ; ? TO TRACE HERE
0750 f28d 25 23              [ 3 ]         BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
0751 f28f 30 8c e9           [ 5 ]         LEAX    MSHOWP,PCR      ; LOAD OP PREP
0752 f292 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
0753 f293 02                               FCB     PDATA1          ; FUNCTION
0754 f294 09 8e              [ 6 ]         ROL     <DELIM          ; SAVE CARRY BIT
0755 f296 30 8d f4 ff        [ 9 ]         LEAX    LASTOP,PCR      ; POINT TO LAST OP
0756 f29a 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
0757 f29b 05                               FCB     OUT4HS          ; FUNCTION
0758 f29c 8d 17              [ 7 ]         BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
0759 f29e 25 37              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0760 f2a0 06 8e              [ 6 ]         ROR     <DELIM          ; RESTORE CARRY BIT
0761 f2a2 25 33              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
0762 f2a4 9e 91              [ 5 ]         LDX     <TRACEC         ; LOAD TRACE COUNT
0763 f2a6 27 2f              [ 3 ]         BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
0764 f2a8 30 1f              [ 5 ]         LEAX    -1,X            ; MINUS ONE
0765 f2aa 9f 91              [ 5 ]         STX     <TRACEC         ; REFRESH
0766 f2ac 27 29              [ 3 ]         BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
0767 f2ae 8d aa              [ 7 ]         BSR     CHKABT          ; ? ABORT THE TRACE
0768 f2b0 25 25              [ 3 ]         BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
0769 f2b2 16 04 05           [ 5 ] NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
0770                               
0771 f2b5 17 01 c7           [ 9 ] REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
0772 f2b8 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0773                               
0774                               * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
0775                               
0776 f2b9 0f 8f              [ 6 ] NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
0777 f2bb 17 02 f9           [ 9 ]         LBSR    ARMBK2         ; ARM BREAKPOINTS
0778 f2be 3b                 [15 ] RTI     RTI                    ; AND CONTINUE USERS PROGRAM
0779                               
0780                               * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
0781                               * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
0782                               * HANDLER.
0783                               * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
0784                               * OUTPUT: DPR LOADED TO WORK PAGE
0785                               
0786 f2bf 3f 07 20 04              ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
0787                               
0788 f2c3 e6 8d f4 d6        [ 9 ] LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
0789 f2c7 1f 9b              [ 6 ]         TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
0790 f2c9 a1 63              [ 5 ]         CMPA    3,S             ; ? IS STACK VALID
0791 f2cb 27 33              [ 3 ]         BEQ     RTS             ; YES, RETURN
0792 f2cd 10 de 97           [ 6 ]         LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
0793 f2d0 30 8c ec           [ 5 ] ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
0794 f2d3 3f                 [19 ]         SWI                     ; SEND OUT BEFORE REGISTERS
0795 f2d4 03                               FCB     PDATA           ; ON NEXT LINE
0796                               * FALL INTO BREAKPOINT HANDLER
0797                               
0798                               **********************************************
0799                               * [SWI FUNCTION 10]
0800                               * BREAKPOINT PROGRAM FUNCTION
0801                               * PRINT REGISTERS AND GO TO COMMAND HANLER
0802                               ***********************************************
0803                               
0804 f2d5 8d de              [ 7 ] ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
0805 f2d7 16 fe 1d           [ 5 ] ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
0806                               
0807                               ********************************************
0808                               * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
0809                               * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
0810                               ********************************************
0811 f2da                          SWI2R   EQU     *               ; SWI2 ENTRY
0812 f2da                          SWI3R   EQU     *               ; SWI3 ENTRY
0813 f2da                          IRQR    EQU     *               ; IRQ ENTRY
0814 f2da 8d e7              [ 7 ] RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
0815 f2dc 20 f7              [ 3 ]         BRA     ZBKPNT          ; FORCE A BREAKPOINT
0816                               
0817                               ******************************************
0818                               * FIRQ HANDLER
0819                               * JUST RETURN FOR THE FIRQ INTERRUPT
0820                               ******************************************
0821 f2be                          FIRQR   EQU     RTI             ; IMMEDIATE RETURN
0822                               
0823                               **************************************************
0824                               * DEFAULT I/O DRIVERS
0825                               **************************************************
0826                               * CIDTA - RETURN CONSOLE INPUT CHARACTER
0827                               * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
0828                               * U VOLATILE
0829                               
0830 f2de de f0              [ 5 ] CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0831 f2e0 a6 c4              [ 4 ]         LDA     ,U              ; LOAD STATUS REGISTER
0832 f2e2 44                 [ 2 ]         LSRA                    ; TEST RECEIVER REGISTER FLAG
0833 f2e3 24 02              [ 3 ]         BCC     CIRTN           ; RETURN IF NOTHING
0834 f2e5 a6 41              [ 5 ]         LDA     1,U             ; LOAD DATA BYTE
0835 f2e7 39                 [ 5 ] CIRTN   RTS                     ; RETURN TO CALLER
0836                               
0837                               * CION - INPUT CONSOLE INITIALIZATION
0838                               * COON - OUTPUT CONSOLE INITIALIZATION
0839                               * A,X VOLATILE
0840 f2e8                          CION   EQU      *
0841                               COON   
0842 f2e8 9e f6              [ 5 ]        LDX      <VECTAB+.PTM
0843 f2ea 86 93              [ 2 ]        LDA	#$93
0844 f2ec a7 01              [ 5 ]        STA      PTMC2-PTM,X
0845 f2ee cc 00 02           [ 3 ]        LDD	#2
0846 f2f1 ed 04              [ 6 ]        STD      PTMTM2-PTM,X
0847 f2f3 4f                 [ 2 ]        CLRA	
0848 f2f4 a7 84              [ 4 ]        STA      PTMC13-PTM,X
0849 f2f6 86 03              [ 2 ]        LDA      #3              ; RESET ACIA CODE
0850 f2f8 9e f0              [ 5 ]        LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
0851 f2fa a7 84              [ 4 ]        STA      ,X              ; STORE INTO STATUS REGISTER
0852 f2fc 86 15              [ 2 ]        LDA      #$15            ; SET CONTROL
0853 f2fe a7 84              [ 4 ]        STA      ,X              ; REGISTER UP
0854 f300 39                 [ 5 ] RTS    RTS                      ; RETURN TO CALLER
0855                               
0856                               * THE FOLLOWING HAVE NO DUTIES TO PERFORM
0857 f300                          CIOFF EQU       RTS             ; CONSOLE INPUT OFF
0858 f300                          COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
0859                               
0860                               * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
0861                               * INPUT: A=CHARACTER TO SEND
0862                               * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
0863                               * ALL REGISTERS TRANSPARENT
0864                               
0865 f301 34 47              [10 ] CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
0866 f303 de f0              [ 5 ]         LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
0867 f305 8d 1b              [ 7 ]         BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
0868 f307 81 10              [ 2 ]         CMPA    #DLE            ; ? DATA LINE ESCAPE
0869 f309 27 12              [ 3 ]         BEQ     CODTRT          ; YES, RETURN
0870 f30b d6 f2              [ 4 ]         LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
0871 f30d 81 0d              [ 2 ]         CMPA    #CR             ; ? CR
0872 f30f 26 02              [ 3 ]         BNE     CODTPD          ; BRANCH NO
0873 f311 d6 f3              [ 4 ]         LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
0874 f313 4f                 [ 2 ] CODTPD  CLRA                    ; CREATE NULL
0875 f314 e7 e4              [ 4 ]         STB     ,S              ; SAVE COUNT
0876 f316 8c                               FCB     SKIP2           ; ENTER LOOP
0877 f317 8d 09              [ 7 ] CODTLP  BSR     CODTAO          ; SEND NULL
0878 f319 6a e4              [ 6 ]         DEC     ,S              ; ? FINISHED
0879 f31b 2a fa              [ 3 ]         BPL     CODTLP          ; NO, CONTINUE WITH MORE
0880 f31d 35 c7              [12 ] CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
0881                               
0882 f31f 17 ff 4e           [ 9 ] CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
0883 f322 e6 c4              [ 4 ] CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
0884 f324 c5 02              [ 2 ]         BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
0885 f326 27 f7              [ 3 ]         BEQ     CODTAD          ; RELEASE CONTROL IF NOT
0886 f328 a7 41              [ 5 ]         STA     1,U             ; STORE INTO DATA REGISTER
0887 f32a 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0888                               *E
0889                               
0890                               * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
0891                               * A IS VOLATILE
0892                               
0893 f32b 86 11              [ 2 ] BSON    LDA     #$11            ; SET READ CODE
0894 f32d 6d 66              [ 7 ]         TST     6,S             ; ? READ OR VERIFY
0895 f32f 26 01              [ 3 ]         BNE     BSON2           ; BRANCH YES
0896 f331 4c                 [ 2 ]         INCA                    ; SET TO WRITE
0897 f332 3f                 [19 ] BSON2   SWI                     ; PERFORM OUTPUT
0898 f333 01                               FCB     OUTCH           ; FUNCTION
0899 f334 0c 8f              [ 6 ]         INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
0900 f336 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0901                               
0902                               * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
0903                               * A,X VOLATILE
0904                               
0905 f337 86 14              [ 2 ] BSOFF   LDA     #$14            ; TO DC4 - STOP
0906 f339 3f                 [19 ]         SWI                     ; SEND OUT
0907 f33a 01                               FCB     OUTCH           ; FUNCTION
0908 f33b 4a                 [ 2 ]         DECA                    ; CHANGE TO DC3 (X-OFF)
0909 f33c 3f                 [19 ]         SWI                     ; SEND OUT
0910 f33d 01                               FCB     OUTCH           ; FUNCTION
0911 f33e 0a 8f              [ 6 ]         DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
0912 f340 8e 61 a8           [ 3 ]         LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
0913 f343 30 1f              [ 5 ] BSOFLP  LEAX    -1,X            ; COUNT DOWN
0914 f345 26 fc              [ 3 ]         BNE     BSOFLP          ; LOOP TILL DONE
0915 f347 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
0916                               
0917                               * BSDTA - READ/VERIFY/PUNCH HANDLER
0918                               * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
0919                               * S+4=START ADDRESS
0920                               * S+2=STOP ADDRESS
0921                               * S+0=RETURN ADDRESS
0922                               * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
0923                               * REGISTERS ARE VOLATILE
0924 f348 ee 62              [ 6 ] BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
0925 f34a 6d 66              [ 7 ]         TST     6,S             ; ? PUNCH
0926 f34c 27 54              [ 3 ]         BEQ     BSDPUN          ; BRANCH YES
0927                               
0928                               * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
0929                               * S+1=BYTE COUNTER
0930                               * S+0=CHECKSUM
0931                               * U HOLDS OFFSET
0932 f34e 32 7d              [ 5 ]         LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
0933 f350 3f                 [19 ] BSDLD1  SWI                     ; GET NEXT CHARACTER
0934 f351 00                               FCB     INCHNP          ; FUNCTION
0935 f352 81 53              [ 2 ] BSDLD2  CMPA    #'S             ; ? START OF S1/S9
0936 f354 26 fa              [ 3 ]         BNE     BSDLD1          ; BRANCH NOT
0937 f356 3f                 [19 ]         SWI                     ; GET NEXT CHARACTER
0938 f357 00                               FCB     INCHNP          ; FUNCTION
0939 f358 81 39              [ 2 ]         CMPA    #'9             ; ? HAVE S9
0940 f35a 27 22              [ 3 ]         BEQ     BSDSRT          ; YES, RETURN GOOD CODE
0941 f35c 81 31              [ 2 ]         CMPA    #'1             ; ? HAVE NEW RECORD
0942 f35e 26 f2              [ 3 ]         BNE     BSDLD2          ; BRANCH IF NOT
0943 f360 6f e4              [ 6 ]         CLR     ,S              ; CLEAR CHECKSUM
0944 f362 8d 21              [ 7 ]         BSR     BYTE            ; OBTAIN BYTE COUNT
0945 f364 e7 61              [ 5 ]         STB     1,S             ; SAVE FOR DECREMENT
0946                               
0947                               * READ ADDRESS
0948 f366 8d 1d              [ 7 ]         BSR     BYTE            ; OBTAIN HIGH VALUE
0949 f368 e7 62              [ 5 ]         STB     2,S             ; SAVE IT
0950 f36a 8d 19              [ 7 ]         BSR     BYTE            ; OBTAIN LOW VALUE
0951 f36c a6 62              [ 5 ]         LDA     2,S             ; MAKE D=VALUE
0952 f36e 31 cb              [ 8 ]         LEAY    D,U             ; Y=ADDRESS+OFFSET
0953                               * STORE TEXT
0954 f370 8d 13              [ 7 ] BSDNXT  BSR     BYTE            ; NEXT BYTE
0955 f372 27 0c              [ 3 ]         BEQ     BSDEOL          ; BRANCH IF CHECKSUM
0956 f374 6d 69              [ 7 ]         TST     9,S             ; ? VERIFY ONLY
0957 f376 2b 02              [ 3 ]         BMI     BSDCMP          ; YES, ONLY COMPARE
0958 f378 e7 a4              [ 4 ]         STB     ,Y              ; STORE INTO MEMORY
0959 f37a e1 a0              [ 6 ] BSDCMP  CMPB    ,Y+             ; ? VALID RAM
0960 f37c 27 f2              [ 3 ]         BEQ     BSDNXT          ; YES, CONTINUE READING
0961 f37e 35 92              [10 ] BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
0962 f380 4c                 [ 2 ] BSDEOL  INCA                    ; ? VALID CHECKSUM
0963 f381 27 cd              [ 3 ]         BEQ     BSDLD1          ; BRANCH YES
0964 f383 20 f9              [ 3 ]         BRA     BSDSRT          ; RETURN Z=0 INVALID
0965                               
0966                               * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
0967 f385 8d 12              [ 7 ] BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
0968 f387 c6 10              [ 2 ]         LDB     #16            ; PREPARE SHIFT
0969 f389 3d                 [11 ]         MUL                    ; OVER TO A
0970 f38a 8d 0d              [ 7 ]         BSR     BYTHEX         ; OBTAIN SECOND HEX
0971 f38c 34 04              [ 6 ]         PSHS    B              ; SAVE HIGH HEX
0972 f38e ab e0              [ 6 ]         ADDA    ,S+            ; COMBINE BOTH SIDES
0973 f390 1f 89              [ 6 ]         TFR     A,B            ; SEND BACK IN B
0974 f392 ab 62              [ 5 ]         ADDA    2,S            ; COMPUTE NEW CHECKSUM
0975 f394 a7 62              [ 5 ]         STA     2,S            ; STORE BACK
0976 f396 6a 63              [ 7 ]         DEC     3,S            ; DECREMENT BYTE COUNT
0977 f398 39                 [ 5 ] BYTRTS  RTS                    ; RETURN TO CALLER
0978                               
0979 f399 3f                 [19 ] BYTHEX  SWI                    ; GET NEXT HEX
0980 f39a 00                               FCB     INCHNP         ; CHARACTER
0981 f39b 17 01 d4           [ 9 ]         LBSR    CNVHEX         ; CONVERT TO HEX
0982 f39e 27 f8              [ 3 ]         BEQ     BYTRTS         ; RETURN IF VALID HEX
0983 f3a0 35 f2              [14 ]         PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
0984                               
0985                               * PUNCH STACK USE: S+8=TO ADDRESS
0986                               *                  S+6=RETURN ADDRESS
0987                               *                  S+4=SAVED PADDING VALUES
0988                               *                  S+2 FROM ADDRESS
0989                               *                  S+1=FRAME COUNT/CHECKSUM
0990                               *                  S+0=BYTE COUNT
0991                               
0992 f3a2 de f2              [ 5 ] BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
0993 f3a4 ae 64              [ 6 ]         LDX     4,S             ; X=FROM ADDRESS
0994 f3a6 34 56              [11 ]         PSHS    U,X,D           ; CREATE STACK WORK AREA
0995 f3a8 cc 00 18           [ 3 ]         LDD     #24             ; SET A=0, B=24
0996 f3ab d7 f2              [ 4 ]         STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
0997 f3ad 3f                 [19 ]         SWI                     ; SEND NULLS OUT
0998 f3ae 01                               FCB     OUTCH           ; FUNCTION
0999 f3af c6 04              [ 2 ]         LDB     #4              ; SETUP NEW LINE PAD TO 4
1000 f3b1 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
1001                               * CALCULATE SIZE
1002 f3b3 ec 68              [ 6 ] BSPGO   LDD     8,S             ; LOAD TO
1003 f3b5 a3 62              [ 7 ]         SUBD    2,S             ; MINUS FROM=LENGTH
1004 f3b7 10 83 00 18        [ 5 ]         CMPD    #24             ; ? MORE THAN 23
1005 f3bb 25 02              [ 3 ]         BLO     BSPOK           ; NO, OK
1006 f3bd c6 17              [ 2 ]         LDB     #23             ; FORCE TO 23 MAX
1007 f3bf 5c                 [ 2 ] BSPOK   INCB                    ; PREPARE COUNTER
1008 f3c0 e7 e4              [ 4 ]         STB     ,S              ; STORE BYTE COUNT
1009 f3c2 cb 03              [ 2 ]         ADDB    #3              ; ADJUST TO FRAME COUNT
1010 f3c4 e7 61              [ 5 ]         STB     1,S             ; SAVE
1011                               
1012                               *PUNCH CR,LF,NULS,S,1
1013 f3c6 30 8c 33           [ 5 ]        LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
1014 f3c9 3f                 [19 ]        SWI                      ; SEND OUT
1015 f3ca 03                              FCB      PDATA           ; FUNCTION
1016                               * SEND FRAME COUNT
1017 f3cb 5f                 [ 2 ]        CLRB                     ; INITIALIZE CHECKSUM
1018 f3cc 30 61              [ 5 ]        LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
1019 f3ce 8d 27              [ 7 ]        BSR      BSPUN2          ; SEND FRAME COUNT
1020                               *DATA ADDRESS
1021 f3d0 8d 25              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS HI
1022 f3d2 8d 23              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS LOW
1023                               *PUNCH DATA
1024 f3d4 ae 62              [ 6 ]        LDX      2,S             ; LOAD START DATA ADDRESS
1025 f3d6 8d 1f              [ 7 ] BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
1026 f3d8 6a e4              [ 6 ]        DEC      ,S              ; ? FINAL BYTE
1027 f3da 26 fa              [ 3 ]        BNE      BSPMRE          ; LOOP IF NOT DONE
1028 f3dc af 62              [ 6 ]        STX      2,S             ; UPDATE FROM ADDRESS VALUE
1029                               *PUNCH CHECKSUM
1030 f3de 53                 [ 2 ]        COMB                     ; COMPLEMENT
1031 f3df e7 61              [ 5 ]        STB      1,S             ; STORE FOR SENDOUT
1032 f3e1 30 61              [ 5 ]        LEAX     1,S             ; POINT TO IT
1033 f3e3 8d 14              [ 7 ]        BSR      BSPUNC          ; SEND OUT AS HEX
1034 f3e5 ae 68              [ 6 ]        LDX      8,S             ; LOAD TOP ADDRESS
1035 f3e7 ac 62              [ 7 ]        CMPX     2,S             ; ? DONE
1036 f3e9 24 c8              [ 3 ]        BHS      BSPGO           ; BRANCH NOT
1037 f3eb 30 8c 11           [ 5 ]        LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
1038 f3ee 3f                 [19 ]        SWI                      ; SEND OUT STRING
1039 f3ef 03                              FCB      PDATA           ; FUNCTION
1040 f3f0 ec 64              [ 6 ]        LDD      4,S             ; RECOVER PAD COUNTS
1041 f3f2 dd f2              [ 5 ]        STD      <VECTAB+.PAD    ; RESTORE
1042 f3f4 4f                 [ 2 ]        CLRA                     ; SET Z=1 FOR OK RETURN
1043 f3f5 35 d6              [13 ]        PULS     PC,U,X,D        ; RETURN WITH OK CODE
1044 f3f7 eb 84              [ 4 ] BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
1045 f3f9 16 fd df           [ 5 ] BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
1046                               
1047 f3fc 53 01 04                 BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
1048 f3ff 53 39 30 33 30 30        BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
1049 f409 0d 0a 04                        FCB      CR,LF,EOT
1050                               
1051                               * HSDTA - HIGH SPEED PRINT MEMORY
1052                               * INPUT: S+4=START ADDRESS
1053                               * S+2=STOP ADDRESS
1054                               * S+0=RETURN ADDRESS
1055                               * X,D VOLATILE
1056                               
1057                               * SEND TITLE
1058                               
1059 f40c 3f                 [19 ] HSDTA   SWI                     ; SEND NEW LINE
1060 f40d 06                               FCB     PCRLF           ; FUNCTION
1061 f40e c6 06              [ 2 ]         LDB     #6              ; PREPARE 6 SPACES
1062 f410 3f                 [19 ] HSBLNK  SWI                     ; SEND BLANK
1063 f411 07                               FCB     SPACE           ; FUNCTION
1064 f412 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1065 f413 26 fb              [ 3 ]         BNE     HSBLNK          ; LOOP IF MORE
1066 f415 5f                 [ 2 ]         CLRB                    ; SETUP BYTE COUNT
1067 f416 1f 98              [ 6 ] HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
1068 f418 17 fd cd           [ 9 ]         LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
1069 f41b 3f                 [19 ]         SWI                     ; SEND BLANK
1070 f41c 07                               FCB     SPACE           ; FUNCTION
1071 f41d 3f                 [19 ]         SWI                     ; SEND ANOTHER
1072 f41e 07                               FCB     SPACE           ; BLANK
1073 f41f 5c                 [ 2 ]         INCB                    ; UP ANOTHER
1074 f420 c1 10              [ 2 ]         CMPB    #$10            ; ? PAST 'F'
1075 f422 25 f2              [ 3 ]         BLO     HSHTTL          ; LOOP UNTIL SO
1076 f424 3f                 [19 ] HSHLNE  SWI                     ; TO NEXT LINE
1077 f425 06                               FCB     PCRLF           ; FUNCTION
1078 f426 25 2f              [ 3 ]         BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
1079 f428 30 64              [ 5 ]         LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
1080 f42a 3f                 [19 ]         SWI                     ; PRINT OUT ADDRESS
1081 f42b 05                               FCB     OUT4HS          ; FUNCTION
1082 f42c ae 64              [ 6 ]         LDX     4,S             ; LOAD ADDRESS PROPER
1083 f42e c6 10              [ 2 ]         LDB     #16             ; NEXT SIXTEEN
1084 f430 3f                 [19 ] HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
1085 f431 04                               FCB     OUT2HS          ; FUNCTION
1086 f432 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1087 f433 26 fb              [ 3 ]         BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
1088 f435 3f                 [19 ]         SWI                     ; SEND BLANK
1089 f436 07                               FCB     SPACE           ; FUNCTION
1090 f437 ae 64              [ 6 ]         LDX     4,S             ; RELOAD FROM ADDRESS
1091 f439 c6 10              [ 2 ]         LDB     #16             ; COUNT
1092 f43b a6 80              [ 6 ] HSHCHR  LDA     ,X+             ; NEXT BYTE
1093 f43d 2b 04              [ 3 ]         BMI     HSHDOT          ; TOO LARGE, TO A DOT
1094 f43f 81 20              [ 2 ]         CMPA    #'              ; ? LOWER THAN A BLANK
1095 f441 24 02              [ 3 ]         BHS     HSHCOK          ; NO, BRANCH OK
1096 f443 86 2e              [ 2 ] HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
1097 f445 3f                 [19 ] HSHCOK  SWI                     ; SEND CHARACTER
1098 f446 01                               FCB     OUTCH           ; FUNCTION
1099 f447 5a                 [ 2 ]         DECB                    ; ? DONE
1100 f448 26 f1              [ 3 ]         BNE     HSHCHR          ; BRANCH NO
1101 f44a ac 62              [ 7 ]         CPX     2,S             ; ? PAST LAST ADDRESS
1102 f44c 24 09              [ 3 ]         BHS     HSDRTN          ; QUIT IF SO
1103 f44e af 64              [ 6 ]         STX     4,S             ; UPDATE FROM ADDRESS
1104 f450 a6 65              [ 5 ]         LDA     5,S             ; LOAD LOW BYTE ADDRESS
1105 f452 48                 [ 2 ]         ASLA                    ; ? TO SECTION BOUNDARY
1106 f453 26 cf              [ 3 ]         BNE     HSHLNE          ; BRANCH IF NOT
1107 f455 20 b5              [ 3 ]         BRA     HSDTA           ; BRANCH IF SO
1108 f457 3f                 [19 ] HSDRTN  SWI                     ; SEND NEW LINE
1109 f458 06                               FCB     PCRLF           ; FUNCTION
1110 f459 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
1111                               *F
1112                               
1113                               ***********************************************
1114                               *     A S S I S T 0 9    C O M M A N D S
1115                               ***********************************************
1116                               
1117                               *************REGISTERS - DISPLAY AND CHANGE REGISTERS
1118 f45a 8d 23              [ 7 ] CREG    BSR     REGPRT          ; PRINT REGISTERS
1119 f45c 4c                 [ 2 ]         INCA                    ; SET FOR CHANGE FUNCTION
1120 f45d 8d 21              [ 7 ]         BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
1121 f45f 39                 [ 5 ]         RTS                     ; RETURN TO COMMAND PROCESSOR
1122                               
1123                               ********************************************
1124                               * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
1125                               * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
1126                               * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
1127                               * DONE.
1128                               
1129                               * REGISTER MASK LIST CONSISTS OF:
1130                               * A) CHARACTERS DENOTING REGISTER
1131                               * B) ZERO FOR ONE BYTE, -1 FOR TWO
1132                               * C) OFFSET ON STACK TO REGISTER POSITION
1133                               * INPUT: SP+4=STACKED REGISTERS
1134                               * A=0 PRINT, A#0 PRINT AND CHANGE
1135                               * OUTPUT: (ONLY FOR REGISTER DISPLAY)
1136                               * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
1137                               * VOLATILE: D,X (CHANGE)
1138                               * B,X (DISPLAY)
1139                               *******************************************
1140                               
1141 f460 50 43 ff 13              REGMSK  FCB     'P,'C,-1,19     ; PC REG
1142 f464 41 00 0a                         FCB     'A,0,10         ; A REG
1143 f467 42 00 0b                         FCB     'B,0,11         ; B REG
1144 f46a 58 ff 0d                         FCB     'X,-1,13        ; X REG
1145 f46d 59 ff 0f                         FCB     'Y,-1,15        ; Y REG
1146 f470 55 ff 11                         FCB     'U,-1,17        ; U REG
1147 f473 53 ff 01                         FCB     'S,-1,1         ; S REG
1148 f476 43 43 00 09                      FCB     'C,'C,0,9       ; CC REG
1149 f47a 44 50 00 0c                      FCB     'D,'P,0,12      ; DP REG
1150 f47e 00                               FCB     0               ; END OF LIST
1151                               
1152 f47f 4f                 [ 2 ] REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
1153 f480 30 e8 10           [ 5 ] REGCHG  LEAX    4+12,S          ; READY STACK VALUE
1154 f483 34 32              [10 ]         PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
1155 f485 31 8c d8           [ 5 ]         LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
1156 f488 ec a0              [ 7 ] REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
1157 f48a 4d                 [ 2 ]         TSTA                    ; ? END OF CHARACTERS
1158 f48b 2f 04              [ 3 ]         BLE     REGP2           ; BRANCH NOT CHARACTER
1159 f48d 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
1160 f48e 01                               FCB     OUTCH           ; FUNCTION BYTE
1161 f48f 20 f7              [ 3 ]         BRA     REGP1           ; CHECK NEXT
1162 f491 86 2d              [ 2 ] REGP2   LDA     #'-             ; READY '-'
1163 f493 3f                 [19 ]         SWI                     ; SEND OUT
1164 f494 01                               FCB     OUTCH           ; WITH OUTCH
1165 f495 30 e5              [ 5 ]         LEAX    B,S             ; X->REGISTER TO PRINT
1166 f497 6d e4              [ 6 ]         TST     ,S              ; ? CHANGE OPTION
1167 f499 26 12              [ 3 ]         BNE     REGCNG          ; BRANCH YES
1168 f49b 6d 3f              [ 7 ]         TST     -1,Y            ; ? ONE OR TWO BYTES
1169 f49d 27 03              [ 3 ]         BEQ     REGP3           ; BRANCH ZERO MEANS ONE
1170 f49f 3f                 [19 ]         SWI                     ; PERFORM WORD HEX
1171 f4a0 05                               FCB     OUT4HS          ; FUNCTION
1172 f4a1 8c                               FCB     SKIP2           ; SKIP BYTE PRINT
1173 f4a2 3f                 [19 ] REGP3   SWI                     ; PERFORM BYTE HEX
1174 f4a3 04                               FCB     OUT2HS          ; FUNCTION
1175 f4a4 ec a0              [ 7 ] REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
1176 f4a6 5d                 [ 2 ]         TSTB                    ; ? END OF ENTRIES
1177 f4a7 26 df              [ 3 ]         BNE     REGP1           ; LOOP IF MORE
1178 f4a9 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1179 f4aa 06                               FCB     PCRLF           ; FUNCTION
1180 f4ab 35 b2              [12 ] REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
1181                               
1182 f4ad 8d 40              [ 7 ] REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
1183 f4af 27 10              [ 3 ]         BEQ     REGNXC          ; IF CHANGE THEN JUMP
1184 f4b1 81 0d              [ 2 ]         CMPA    #CR             ; ? NO MORE DESIRED
1185 f4b3 27 1e              [ 3 ]         BEQ     REGAGN          ; BRANCH NOPE
1186 f4b5 e6 3f              [ 5 ]         LDB     -1,Y            ; LOAD SIZE FLAG
1187 f4b7 5a                 [ 2 ]         DECB                    ; MINUS ONE
1188 f4b8 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
1189 f4b9 58                 [ 2 ]         ASLB                    ; TIMES TWO (=2 OR =4)
1190 f4ba 3f                 [19 ] REGSKP  SWI                     ; PERFORM SPACES
1191 f4bb 07                               FCB     SPACE           ; FUNCTION
1192 f4bc 5a                 [ 2 ]         DECB
1193 f4bd 26 fb              [ 3 ]         BNE     REGSKP          ; LOOP IF MORE
1194 f4bf 20 e3              [ 3 ]         BRA     REG4            ; CONTINUE WITH NEXT REGISTER
1195 f4c1 a7 e4              [ 4 ] REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
1196                               *                               ; (ALWAYS > 0)
1197 f4c3 dc 9b              [ 5 ]         LDD     <NUMBER         ; OBTAIN BINARY RESULT
1198 f4c5 6d 3f              [ 7 ]         TST     -1,Y            ; ? TWO BYTES WORTH
1199 f4c7 26 02              [ 3 ]         BNE     REGTWO          ; BRANCH YES
1200 f4c9 a6 82              [ 6 ]         LDA     ,-X             ; SETUP FOR TWO
1201 f4cb ed 84              [ 5 ] REGTWO  STD     ,X              ; STORE IN NEW VALUE
1202 f4cd a6 e4              [ 4 ]         LDA     ,S              ; RECOVER DELIMITER
1203 f4cf 81 0d              [ 2 ]         CMPA    #CR             ; ? END OF CHANGES
1204 f4d1 26 d1              [ 3 ]         BNE     REG4            ; NO, KEEP ON TRUCK'N
1205                               * MOVE STACKED DATA TO NEW STACK IN CASE STACK
1206                               * POINTER HAS CHANGED
1207 f4d3 30 8d f2 7a        [ 9 ] REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
1208 f4d7 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT
1209 f4d9 35 02              [ 6 ] REGTF1  PULS    A               ; NEXT BYTE
1210 f4db a7 80              [ 6 ]         STA     ,X+             ; STORE INTO TEMP
1211 f4dd 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1212 f4de 26 f9              [ 3 ]         BNE     REGTF1          ; LOOP IF MORE
1213 f4e0 10 ee 88 ec        [ 7 ]         LDS     -20,X           ; LOAD NEW STACK POINTER
1214 f4e4 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT AGAIN
1215 f4e6 a6 82              [ 6 ] REGTF2 LDA      ,-X             ; NEXT TO STORE
1216 f4e8 34 02              [ 6 ]        PSHS     A               ; BACK ONTO NEW STACK
1217 f4ea 5a                 [ 2 ]        DECB                     ; COUNT DOWN
1218 f4eb 26 f9              [ 3 ]        BNE      REGTF2          ; LOOP IF MORE
1219 f4ed 20 bc              [ 3 ]        BRA      REGRTN          ; GO RESTART COMMAND
1220                               
1221                               *********************************************
1222                               * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
1223                               * THE ACTIVE EXPRESSION HANDLER IS USED.
1224                               * INPUT: S=RETURN ADDRESS
1225                               * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
1226                               * (IF DELM NOT ZERO)
1227                               * "NUMBER"=WORD BINARY RESULT
1228                               * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
1229                               * REGISTERS ARE TRANSPARENT
1230                               **********************************************
1231                               * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
1232                               *
1233                               * THE FLAG "DELIM" IS USED AS FOLLOWS:
1234                               * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
1235                               * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
1236 f4ef 4f                 [ 2 ] BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
1237 f4f0 8c                               FCB     SKIP2           ; SKIP NEXT INSTRUCTION
1238                               * BUILD WITH LEADING BLANKS
1239 f4f1 86 20              [ 2 ] BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
1240 f4f3 97 8e              [ 4 ]         STA     <DELIM          ; STORE AS DELIMITER
1241 f4f5 6e 9d f2 f3        [11 ]         JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
1242                               * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
1243                               * 1) HEX INPUT
1244                               * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
1245                               * 3) 'P' FOR PROGRAM COUNTER ADDRESS
1246                               * 4) 'W' FOR WINDOW VALUE
1247                               * 5) '@' FOR INDIRECT VALUE
1248                               
1249 f4f9 34 14              [ 8 ] EXP1    PSHS    X,B             ; SAVE REGISTERS
1250 f4fb 8d 5c              [ 7 ] EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
1251 f4fd 27 18              [ 3 ]         BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
1252                               * SKIP BLANKS IF DESIRED
1253 f4ff 91 8e              [ 4 ]         CMPA    <DELIM          ; ? CORRECT DELIMITER
1254 f501 27 f8              [ 3 ]         BEQ     EXPDLM          ; YES, IGNORE IT
1255                               * TEST FOR M OR P
1256 f503 9e 9e              [ 5 ]         LDX     <ADDR           ; DEFAULT FOR 'M'
1257 f505 81 4d              [ 2 ]         CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
1258 f507 27 16              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1259 f509 9e 93              [ 5 ]         LDX     <PCNTER         ; DEFAULT FOR 'P'
1260 f50b 81 50              [ 2 ]         CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
1261 f50d 27 10              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
1262 f50f 9e a0              [ 5 ]         LDX     <WINDOW         ; DEFAULT TO WINDOW
1263 f511 81 57              [ 2 ]         CMPA    #'W             ; ? WINDOW WANTED
1264 f513 27 0a              [ 3 ]         BEQ     EXPTDL
1265                               
1266 f515 35 94              [10 ] EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
1267                               * GOT HEX, NOW CONTINUE BUILDING
1268 f517 8d 44              [ 7 ] EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
1269 f519 27 fc              [ 3 ]         BEQ     EXP2            ; CONTINUE IF MORE
1270 f51b 20 0a              [ 3 ]         BRA     EXPCDL          ; SEARCH FOR +/-
1271                               * STORE VALUE AND CHECK IF NEED DELIMITER
1272 f51d ae 84              [ 5 ] EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
1273 f51f 9f 9b              [ 5 ] EXPTDL  STX     <NUMBER         ; STORE RESULT
1274 f521 0d 8e              [ 6 ]         TST     <DELIM          ; ? TO FORCE A DELIMITER
1275 f523 27 f0              [ 3 ]         BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
1276 f525 8d 62              [ 7 ]         BSR     READ            ; OBTAIN NEXT CHARACTER
1277                               * TEST FOR + OR -
1278 f527 9e 9b              [ 5 ] EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
1279 f529 81 2b              [ 2 ]         CMPA    #'+             ; ? ADD OPERATOR
1280 f52b 26 0e              [ 3 ]         BNE     EXPCHM          ; BRANCH NOT
1281 f52d 8d 23              [ 7 ]         BSR     EXPTRM          ; COMPUTE NEXT TERM
1282 f52f 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1283 f531 dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NEW TERM
1284 f533 30 8b              [ 8 ] EXPADD  LEAX    D,X             ; ADD TO X
1285 f535 9f 9b              [ 5 ]         STX     <NUMBER         ; STORE AS NEW RESULT
1286 f537 35 02              [ 6 ]         PULS    A               ; RESTORE DELIMITER
1287 f539 20 ec              [ 3 ]         BRA     EXPCDL          ; NOW TEST IT
1288 f53b 81 2d              [ 2 ] EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
1289 f53d 27 07              [ 3 ]         BEQ     EXPSUB          ; BRANCH IF SO
1290 f53f 81 40              [ 2 ]         CMPA    #'@             ; ? INDIRECTION DESIRED
1291 f541 27 da              [ 3 ]         BEQ     EXPTDI          ; BRANCH IF SO
1292 f543 5f                 [ 2 ]         CLRB                    ; SET DELIMITER RETURN
1293 f544 20 cf              [ 3 ]         BRA     EXPRTN          ; AND RETURN TO CALLER
1294 f546 8d 0a              [ 7 ] EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
1295 f548 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
1296 f54a dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD UP NEXT TERM
1297 f54c 40                 [ 2 ]         NEGA                    ; NEGATE A
1298 f54d 50                 [ 2 ]         NEGB                    ; NEGATE B
1299 f54e 82 00              [ 2 ]         SBCA    #0              ; CORRECT FOR A
1300 f550 20 e1              [ 3 ]         BRA     EXPADD          ; GO ADD TO EXPRESSION
1301                               * COMPUTE NEXT EXPRESSION TERM
1302                               * OUTPUT: X=OLD VALUE
1303                               * 'NUMBER'=NEXT TERM
1304 f552 8d 9d              [ 7 ] EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
1305 f554 27 32              [ 3 ]         BEQ     CNVRTS          ; RETURN IF VALID NUMBER
1306 f556 16 fc 01           [ 5 ] BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
1307                               
1308                               *********************************************
1309                               * BUILD BINARY VALUE USING INPUT CHARACTERS.
1310                               * INPUT: A=ASCII HEX VALUE OR DELIMITER
1311                               * SP+0=RETURN ADDRESS
1312                               * SP+2=16 BIT RESULT AREA
1313                               * OUTPUT: Z=1 A=BINARY VALUE
1314                               * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
1315                               * VOLATILE: D
1316                               ****************************************
1317 f559 0f 9b              [ 6 ] BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
1318 f55b 0f 9c              [ 6 ]         CLR     <NUMBER+1       ; CLEAR NUMBER
1319 f55d 8d 2a              [ 7 ] BLDHEX  BSR     READ            ; GET INPUT CHARACTER
1320 f55f 8d 11              [ 7 ] BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
1321 f561 26 25              [ 3 ]         BNE     CNVRTS          ; RETURN IF NOT A NUMBER
1322 f563 c6 10              [ 2 ]         LDB     #16             ; PREPARE SHIFT
1323 f565 3d                 [11 ]         MUL                     ; BY FOUR PLACES
1324 f566 86 04              [ 2 ]         LDA     #4              ; ROTATE BINARY INTO VALUE
1325 f568 58                 [ 2 ] BLDSHF  ASLB                    ; OBTAIN NEXT BIT
1326 f569 09 9c              [ 6 ]         ROL     <NUMBER+1       ; INTO LOW BYTE
1327 f56b 09 9b              [ 6 ]         ROL     <NUMBER         ; INTO HI BYTE
1328 f56d 4a                 [ 2 ]         DECA                    ; COUNT DOWN
1329 f56e 26 f8              [ 3 ]         BNE     BLDSHF          ; BRANCH IF MORE TO DO
1330 f570 20 14              [ 3 ]         BRA     CNVOK           ; SET GOOD RETURN CODE
1331                               
1332                               ****************************************
1333                               * CONVERT ASCII CHARACTER TO BINARY BYTE
1334                               * INPUT: A=ASCII
1335                               * OUTPUT: Z=1 A=BINARY VALUE
1336                               * Z=0 IF INVALID
1337                               * ALL REGISTERS TRANSPARENT
1338                               * (A UNALTERED IF INVALID HEX)
1339                               **************************************
1340 f572 81 30              [ 2 ] CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
1341 f574 25 12              [ 3 ]         BLO     CNVRTS          ; BRANCH NOT VALUE
1342 f576 81 39              [ 2 ]         CMPA    #'9             ; ? POSSIBLE A-F
1343 f578 2f 0a              [ 3 ]         BLE     CNVGOT          ; BRANCH NO TO ACCEPT
1344 f57a 81 41              [ 2 ]         CMPA    #'A             ; ? LESS THEN TEN
1345 f57c 25 0a              [ 3 ]         BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
1346 f57e 81 46              [ 2 ]         CMPA    #'F             ; ? NOT TOO LARGE
1347 f580 22 06              [ 3 ]         BHI     CNVRTS          ; NO, RETURN TOO LARGE
1348 f582 80 07              [ 2 ]         SUBA    #7              ; DOWN TO BINARY
1349 f584 84 0f              [ 2 ] CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
1350 f586 1a 04              [ 3 ] CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
1351 f588 39                 [ 5 ] CNVRTS  RTS                     ; RETURN TO CALLER
1352                               
1353                               * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
1354 f589 3f                 [19 ] READ     SWI                    ; GET NEXT CHARACTER
1355 f58a 00                                FCB    INCHNP          ; FUNCTION
1356 f58b 81 18              [ 2 ]          CMPA   #CAN            ; ? ABORT COMMAND
1357 f58d 27 c7              [ 3 ]          BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
1358 f58f 39                 [ 5 ]          RTS                    ; RETURN TO CALLER
1359                               *G
1360                               
1361                               ***************GO - START PROGRAM EXECUTION
1362 f590 8d 01              [ 7 ] CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
1363 f592 3b                 [15 ]          RTI                    ; START EXECUTING
1364                               
1365                               * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
1366                               * BREAKPOINTS.
1367 f593 35 30              [ 9 ] GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
1368 f595 34 10              [ 7 ]          PSHS   X               ; STORE RETURN BACK
1369 f597 26 19              [ 3 ]          BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
1370                               
1371                               * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
1372                               * IMMEDIATE BREAKPOINT.
1373 f599 17 01 b6           [ 9 ]          LBSR   CBKLDR          ; SEARCH BREAKPOINTS
1374 f59c ae 6c              [ 6 ]          LDX    12,S            ; LOAD PROGRAM COUNTER
1375 f59e 5a                 [ 2 ] ARMBLP  DECB                    ; COUNT DOWN
1376 f59f 2b 16              [ 3 ]         BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
1377 f5a1 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
1378 f5a3 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
1379 f5a5 26 f7              [ 3 ]         BNE     ARMBLP          ; LOOP IF NOT
1380 f5a7 81 3f              [ 2 ]         CMPA    #$3F            ; ? SWI BREAKPOINTED
1381 f5a9 26 02              [ 3 ]         BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
1382 f5ab 97 fb              [ 4 ]         STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
1383 f5ad 0c 8f              [ 6 ] ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
1384 f5af 16 01 06           [ 5 ]         LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
1385                               
1386                               * OBTAIN NEW PROGRAM COUNTER
1387 f5b2 17 00 bb           [ 9 ] GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
1388 f5b5 ed 6c              [ 6 ]         STD     12,S            ; STORE INTO STACK
1389 f5b7 17 01 98           [ 9 ] ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
1390 f5ba 00 fa              [ 6 ]         NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
1391 f5bc 5a                 [ 2 ] ARMLOP  DECB                    ; ? DONE
1392 f5bd 2b c9              [ 3 ]         BMI     CNVRTS          ; RETURN WHEN DONE
1393 f5bf a6 b4              [ 7 ]         LDA     [,Y]            ; LOAD OPCODE
1394 f5c1 a7 30              [ 5 ]         STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
1395 f5c3 86 3f              [ 2 ]         LDA     #$3F            ; READY "SWI" OPCODE
1396 f5c5 a7 b1              [10 ]         STA     [,Y++]          ; STORE AND MOVE UP TABLE
1397 f5c7 20 f3              [ 3 ]         BRA     ARMLOP          ; AND CONTINUE
1398                               
1399                               *******************CALL - CALL ADDRESS AS SUBROUTINE
1400 f5c9 8d c8              [ 7 ] CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
1401 f5cb 35 7f              [15 ]         PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
1402 f5cd ad f1              [13 ]         JSR     [,S++]          ; CALL USER SUBROUTINE
1403 f5cf 3f                 [19 ] CGOBRK  SWI                     ; PERFORM BREAKPOINT
1404 f5d0 0a                               FCB     BRKPT           ; FUNCTION
1405 f5d1 20 fc              [ 3 ]         BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
1406                               
1407                               ****************MEMORY - DISPLAY/CHANGE MEMORY
1408                               * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
1409                               * THE COMMAND HANDLER FOR QUICK COMMANDS
1410 f5d3 17 00 9a           [ 9 ] CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
1411 f5d6 dd 9e              [ 5 ] CMEMN   STD     <ADDR           ; STORE DEFAULT
1412 f5d8 9e 9e              [ 5 ] CMEM2   LDX     <ADDR           ; LOAD POINTER
1413 f5da 17 fb fe           [ 9 ]         LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
1414 f5dd 86 2d              [ 2 ]         LDA     #'-             ; LOAD DELIMITER
1415 f5df 3f                 [19 ]         SWI                     ; SEND OUT
1416 f5e0 01                               FCB     OUTCH           ; FUNCTION
1417 f5e1 17 ff 0b           [ 9 ] CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
1418 f5e4 27 0a              [ 3 ]         BEQ     CMENUM          ; BRANCH IF NUMBER
1419                               * COMA - SKIP BYTE
1420 f5e6 81 2c              [ 2 ]         CMPA    #',             ; ? COMMA
1421 f5e8 26 0e              [ 3 ]         BNE     CMNOTC          ; BRANCH NOT
1422 f5ea 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1423 f5ec 30 01              [ 5 ]         LEAX    1,X             ; TO NEXT BYTE
1424 f5ee 20 f1              [ 3 ]         BRA     CMEM4           ; AND INPUT IT
1425 f5f0 d6 9c              [ 4 ] CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
1426 f5f2 8d 47              [ 7 ]         BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
1427 f5f4 81 2c              [ 2 ]         CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
1428 f5f6 27 e9              [ 3 ]         BEQ     CMEM4           ; BRANCH YES
1429                               * QUOTED STRING
1430 f5f8 81 27              [ 2 ] CMNOTC  CMPA    #$27            ; ? QUOTED STRING
1431 f5fa 26 0c              [ 3 ]         BNE     CMNOTQ          ; BRANCH NO
1432 f5fc 8d 8b              [ 7 ] CMESTR  BSR     READ            ; OBTAIN NEXT CHARACTER
1433 f5fe 81 27              [ 2 ]         CMPA    #$27            ; ? END OF QUOTED STRING
1434 f600 27 0c              [ 3 ]         BEQ     CMSPCE          ; YES, QUIT STRING MODE
1435 f602 1f 89              [ 6 ]         TFR     A,B             ; TO B FOR SUBROUTINE
1436 f604 8d 35              [ 7 ]         BSR     MUPDAT          ; GO UPDATE BYTE
1437 f606 20 f4              [ 3 ]         BRA     CMESTR          ; GET NEXT CHARACTER
1438                               * BLANK - NEXT BYTE
1439 f608 81 20              [ 2 ] CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
1440 f60a 26 06              [ 3 ]         BNE     CMNOTB          ; BRANCH NOT
1441 f60c 9f 9e              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
1442 f60e 3f                 [19 ] CMSPCE  SWI                     ; GIVE SPACE
1443 f60f 07                               FCB     SPACE           ; FUNCTION
1444 f610 20 c6              [ 3 ]         BRA     CMEM2           ; NOW PROMPT FOR NEXT
1445                               
1446                               * LINE FEED - NEXT BYTE WITH ADDRESS
1447 f612 81 0a              [ 2 ] CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
1448 f614 26 08              [ 3 ]         BNE     CMNOTL          ; BRANCH NO
1449 f616 86 0d              [ 2 ]         LDA     #CR             ; GIVE CARRIAGE RETURN
1450 f618 3f                 [19 ]         SWI                     ; TO CONSOLE
1451 f619 01                               FCB     OUTCH           ; HANDLER
1452 f61a 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEXT ADDRESS
1453 f61c 20 0a              [ 3 ]         BRA     CMPADP          ; BRANCH TO SHOW
1454                               
1455                               * UP ARROW - PREVIOUS BYTE AND ADDRESS
1456 f61e 81 5e              [ 2 ] CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
1457 f620 26 0a              [ 3 ]         BNE     CMNOTU          ; BRANCH NOT
1458 f622 30 1e              [ 5 ]         LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
1459 f624 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER
1460 f626 3f                 [19 ] CMPADS  SWI                     ; FORCE NEW LINE
1461 f627 06                               FCB     PCRLF           ; FUNCTION
1462 f628 8d 07              [ 7 ] CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
1463 f62a 20 ac              [ 3 ]         BRA     CMEM2           ; THEN PROMPT FOR INPUT
1464                               
1465                               * SLASH - NEXT BYTE WITH ADDRESS
1466 f62c 81 2f              [ 2 ] CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
1467 f62e 27 f6              [ 3 ]         BEQ     CMPADS          ; YES, SEND ADDRESS
1468 f630 39                 [ 5 ]         RTS                     ; RETURN FROM COMMAND
1469                               
1470                               * PRINT CURRENT ADDRESS
1471 f631 9e 9e              [ 5 ] PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
1472 f633 34 10              [ 7 ]         PSHS    X               ; SAVE X ON STACK
1473 f635 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT FOR DISPLAY
1474 f637 3f                 [19 ]         SWI                     ; DISPLAY POINTER IN HEX
1475 f638 05                               FCB     OUT4HS          ; FUNCTION
1476 f639 35 90              [ 9 ]         PULS    PC,X            ; RECOVER POINTER AND RETURN
1477                               
1478                               * UPDATE BYTE
1479 f63b 9e 9e              [ 5 ] MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
1480 f63d e7 80              [ 6 ]         STB     ,X+             ; STORE AND INCREMENT X
1481 f63f e1 1f              [ 5 ]         CMPB    -1,X            ; ? SUCCESFULL STORE
1482 f641 26 03              [ 3 ]         BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
1483 f643 9f 9e              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER VALUE
1484 f645 39                 [ 5 ]         RTS                     ; BACK TO CALLER
1485 f646 34 02              [ 6 ] MUPBAD  PSHS    A               ; SAVE A REGISTER
1486 f648 86 3f              [ 2 ]         LDA     #'?             ; SHOW INVALID
1487 f64a 3f                 [19 ]         SWI                     ; SEND OUT
1488 f64b 01                               FCB     OUTCH           ; FUNCTION
1489 f64c 35 82              [ 8 ]         PULS    PC,A            ; RETURN TO CALLER
1490                               
1491                               ********************WINDOW - SET WINDOW VALUE
1492 f64e 8d 20              [ 7 ] CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
1493 f650 dd a0              [ 5 ]         STD     <WINDOW         ; STORE IT IN
1494 f652 39                 [ 5 ]         RTS                     ; END COMMAND
1495                               
1496                               ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
1497 f653 8d 1b              [ 7 ] CDISP   BSR     CDNUM           ; FETCH ADDRESS
1498 f655 c4 f0              [ 2 ]         ANDB    #$F0            ; FORCE TO 16 BOUNDARY
1499 f657 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1500 f659 30 2f              [ 5 ]         LEAX    15,Y            ; DEFAULT LENGTH
1501 f65b 25 04              [ 3 ]         BCS     CDISPS          ; BRANCH IF END OF INPUT
1502 f65d 8d 11              [ 7 ]         BSR     CDNUM           ; OBTAIN COUNT
1503 f65f 30 ab              [ 8 ]         LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
1504 f661 34 30              [ 9 ] CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
1505 f663 10 a3 62           [ 8 ]         CMPD    2,S             ; ? WAS IT COUNT
1506 f666 23 02              [ 3 ]         BLS     CDCNT           ; BRANCH YES
1507 f668 ed e4              [ 5 ]         STD     ,S              ; STORE HIGH ADDRESS
1508 f66a ad 9d f1 74        [15 ] CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
1509 f66e 35 e0              [11 ]         PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
1510                               
1511                               * OBTAIN NUMBER - ABORT IF NONE
1512                               * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
1513                               * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
1514                               * ELSE C=0
1515 f670 17 fe 7e           [ 9 ] CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
1516 f673 26 09              [ 3 ]         BNE     CDBADN          ; BRANCH IF INVALID
1517 f675 81 2f              [ 2 ]         CMPA    #'/             ; ? VALID DELIMITER
1518 f677 22 05              [ 3 ]         BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
1519 f679 81 0e              [ 2 ]         CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
1520 f67b dc 9b              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER
1521 f67d 39                 [ 5 ]         RTS                     ; RETURN WITH COMPARE
1522 f67e 16 fa d9           [ 5 ] CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
1523                               
1524                               *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
1525 f681 8d ed              [ 7 ] CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
1526 f683 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
1527 f685 8d e9              [ 7 ]         BSR     CDNUM           ; OBTAIN END ADDRESS
1528 f687 6f e2              [ 8 ]         CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
1529 f689 34 26              [ 9 ]         PSHS    Y,D             ; STORE VALUES ON STACK
1530 f68b ad 9d f1 55        [15 ] CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
1531 f68f ad 9d f1 53        [15 ]         JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
1532 f693 34 01              [ 6 ]         PSHS    CC              ; SAVE RETURN CODE
1533 f695 ad 9d f1 4f        [15 ]         JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
1534 f699 35 01              [ 6 ]         PULS    CC              ; OBTAIN CONDITION CODE SAVED
1535 f69b 26 e1              [ 3 ]         BNE     CDBADN          ; BRANCH IF ERROR
1536 f69d 35 b2              [12 ]         PULS    PC,Y,X,A        ; RETURN FROM COMMAND
1537                               
1538                               *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
1539 f69f 8d 01              [ 7 ] CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
1540 f6a1 01                               FCB     1               ; LOAD FUNCTION CODE FOR PACKET
1541                               
1542 f6a2 33 f1              [10 ] CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
1543 f6a4 33 d4              [ 7 ]         LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
1544 f6a6 27 03              [ 3 ]         BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
1545 f6a8 8d c6              [ 7 ]         BSR     CDNUM           ; OBTAIN OFFSET
1546 f6aa 8c                               FCB     SKIP2           ; SKIP DEFAULT OFFSET
1547 f6ab 4f                 [ 2 ] CLVDFT  CLRA                    ; CREATE ZERO OFFSET
1548 f6ac 5f                 [ 2 ]         CLRB                    ; AS DEFAULT
1549 f6ad 34 4e              [10 ]         PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
1550 f6af 20 da              [ 3 ]         BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
1551                               
1552                               ******************VERIFY - COMPARE MEMORY WITH FILES
1553 f6b1 8d ef              [ 7 ] CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
1554 f6b3 ff                               FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
1555                               
1556                               *******************TRACE - TRACE INSTRUCTIONS
1557                               ******************* . - SINGLE STEP TRACE
1558 f6b4 8d ba              [ 7 ] CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
1559 f6b6 dd 91              [ 5 ]         STD     <TRACEC         ; STORE COUNT
1560 f6b8 32 62              [ 5 ] CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
1561 f6ba ee f8 0a           [ 9 ] CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
1562 f6bd df 99              [ 5 ]         STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
1563 f6bf de f6              [ 5 ]         LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
1564 f6c1 cc 07 01           [ 3 ]         LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
1565 f6c4 ed 42              [ 6 ]         STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
1566 f6c6 3b                 [15 ]         RTI                     ; RETURN FOR ONE INSTRUCTION
1567                               
1568                               *************NULLS  -  SET NEW LINE AND CHAR PADDING
1569 f6c7 8d a7              [ 7 ] CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
1570 f6c9 dd f2              [ 5 ]         STD     <VECTAB+.PAD    ; RESET VALUES
1571 f6cb 39                 [ 5 ]         RTS                     ; END COMMAND
1572                               
1573                               ******************STLEVEL - SET STACK TRACE LEVEL
1574 f6cc 27 05              [ 3 ] CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
1575 f6ce 8d a0              [ 7 ]         BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
1576 f6d0 dd f8              [ 5 ]         STD     <SLEVEL         ; STORE NEW ENTRY
1577 f6d2 39                 [ 5 ]         RTS                     ; TO COMMAND HANDLER
1578 f6d3 30 6e              [ 5 ] STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
1579 f6d5 9f f8              [ 5 ]         STX     <SLEVEL         ; AND STORE IT
1580 f6d7 39                 [ 5 ]         RTS                     ; END COMMAND
1581                               
1582                               ******************OFFSET - COMPUTE SHORT AND LONG
1583                               ******************                  BRANCH OFFSETS
1584 f6d8 8d 96              [ 7 ] COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
1585 f6da 1f 01              [ 6 ]         TFR     D,X             ; USE AS FROM ADDRESS
1586 f6dc 8d 92              [ 7 ]         BSR     CDNUM           ; OBTAIN TO ADDRESS
1587                               * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
1588 f6de 30 01              [ 5 ]         LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
1589 f6e0 34 30              [ 9 ]         PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
1590 f6e2 a3 e4              [ 6 ]         SUBD    ,S              ; FIND OFFSET
1591 f6e4 ed e4              [ 5 ]         STD     ,S              ; SAVE OVER STACK
1592 f6e6 30 61              [ 5 ]         LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
1593 f6e8 1d                 [ 2 ]         SEX                     ; SIGN EXTEND LOW BYTE
1594 f6e9 a1 e4              [ 4 ]         CMPA    ,S              ; ? VALID ONE BYTE OFFSET
1595 f6eb 26 02              [ 3 ]         BNE     COFNO1          ; BRANCH IF NOT
1596 f6ed 3f                 [19 ]         SWI                     ; SHOW ONE BYTE OFFSET
1597 f6ee 04                               FCB     OUT2HS          ; FUNCTION
1598 f6ef ee e4              [ 5 ] COFNO1  LDU     ,S              ; RELOAD OFFSET
1599 f6f1 33 5f              [ 5 ]         LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
1600 f6f3 ef 84              [ 5 ]         STU     ,X              ; STORE BACK WHERE X POINTS NOW
1601 f6f5 3f                 [19 ]         SWI                     ; SHOW TWO BYTE OFFSET
1602 f6f6 05                               FCB     OUT4HS          ; FUNCTION
1603 f6f7 3f                 [19 ]         SWI                     ; FORCE NEW LINE
1604 f6f8 06                               FCB     PCRLF           ; FUNCTION
1605 f6f9 35 96              [11 ]         PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
1606                               *H
1607                               
1608                               *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
1609                               *************             BREAKPOINTS
1610 f6fb 27 23              [ 3 ] CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
1611 f6fd 17 fd f1           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
1612 f700 27 2c              [ 3 ]         BEQ     CBKADD          ; BRANCH TO ADD IF SO
1613 f702 81 2d              [ 2 ]         CMPA    #'-             ; ? CORRECT DELIMITER
1614 f704 26 3f              [ 3 ]         BNE     CBKERR          ; NO, BRANCH FOR ERROR
1615 f706 17 fd e8           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
1616 f709 27 03              [ 3 ]         BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
1617 f70b 0f fa              [ 6 ]         CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
1618 f70d 39                 [ 5 ] CBKRTS  RTS                     ; END COMMAND
1619                               * DELETE THE ENTRY
1620 f70e 8d 40              [ 7 ] CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
1621 f710 5a                 [ 2 ] CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
1622 f711 2b 32              [ 3 ]         BMI     CBKERR          ; BRANCH NO, ERROR
1623 f713 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS THE ENTRY
1624 f715 26 f9              [ 3 ]         BNE     CBKDLP          ; NO, TRY NEXT
1625                               * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
1626 f717 ae a1              [ 8 ] CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
1627 f719 af 3c              [ 6 ]         STX     -4,Y            ; MOVE DOWN BY ONE
1628 f71b 5a                 [ 2 ]         DECB                    ; ? DONE
1629 f71c 2a f9              [ 3 ]         BPL     CBKDLM          ; NO, CONTINUE MOVE
1630 f71e 0a fa              [ 6 ]         DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
1631 f720 8d 2e              [ 7 ] CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
1632 f722 27 e9              [ 3 ]         BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
1633 f724 30 a1              [ 7 ] CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
1634 f726 3f                 [19 ]         SWI                     ; DISPLAY IN HEX
1635 f727 05                               FCB     OUT4HS          ; FUNCTION
1636 f728 5a                 [ 2 ]         DECB                    ; COUNT DOWN
1637 f729 26 f9              [ 3 ]         BNE     CBKDSL          ; LOOP IF NGABLE RAM
1638 f72b 3f                 [19 ]         SWI                     ; SKIP TO NEW LINK
1639 f72c 06                               FCB     PCRLF           ; FUNCTIONRTS
1640 f72d 39                 [ 5 ]         RTS
1641                               
1642                               * ADD NEW ENTRY
1643 f72e 8d 20              [ 7 ] CBKADD  BSR     CBKSET          ; SETUP REGISTERS
1644 f730 c1 08              [ 2 ]         CMPB    #NUMBKP         ; ? ALREADY FULL
1645 f732 27 11              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1646 f734 a6 84              [ 4 ]         LDA     ,X              ; LOAD BYTE TO TRAP
1647 f736 e7 84              [ 4 ]         STB     ,X              ; TRY TO CHANGE
1648 f738 e1 84              [ 4 ]         CMPB    ,X              ; ? CHANGEABLE RAM
1649 f73a 26 09              [ 3 ]         BNE     CBKERR          ; BRANCH ERROR IF NOT
1650 f73c a7 84              [ 4 ]         STA ,X                  ; RESTORE BYTE
1651 f73e 5a                 [ 2 ] CBKADL  DECB                    ; COUNT DOWN
1652 f73f 2b 07              [ 3 ]         BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
1653 f741 ac a1              [ 9 ]         CMPX    ,Y++            ; ? ENTRY ALREADY HERE
1654 f743 26 f9              [ 3 ]         BNE     CBKADL          ; LOOP IF NOT
1655 f745 16 fa 12           [ 5 ] CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
1656 f748 af a4              [ 5 ] CBKADT  STX ,Y                  ; ADD THIS ENTRY
1657 f74a 6f 31              [ 7 ]         CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
1658 f74c 0c fa              [ 6 ]         INC     <BKPTCT         ; ADD ONE TO COUNT
1659 f74e 20 d0              [ 3 ]         BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
1660                               * SETUP REGISTERS FOR SCAN
1661 f750 9e 9b              [ 5 ] CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
1662 f752 31 8d f0 5c        [ 9 ] CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
1663 f756 d6 fa              [ 4 ]         LDB     <BKPTCT         ; LOAD ENTRY COUNT
1664 f758 39                 [ 5 ]         RTS                     ; RETURN
1665                               
1666                               *****************ENCODE  -  ENCODE A POSTBYTE
1667 f759 6f e2              [ 8 ] CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
1668 f75b 5f                 [ 2 ]         CLRB                    ; ZERO POSTBYTE VALUE
1669 f75c 30 8c 3f           [ 5 ]         LEAX    <CONV1,PCR      ; START TABLE SEARCH
1670 f75f 3f                 [19 ]         SWI                     ; OBTAIN FIRST CHARACTER
1671 f760 00                               FCB     INCHNP          ; FUNCTION
1672 f761 81 5b              [ 2 ]         CMPA    #'[             ; ? INDIRECT HERE
1673 f763 26 06              [ 3 ]         BNE     CEN2            ; BRANCH IF NOT
1674 f765 86 10              [ 2 ]         LDA     #$10            ; SET INDIRECT BIT ON
1675 f767 a7 e4              [ 4 ]         STA     ,S              ; SAVE FOR LATER
1676 f769 3f                 [19 ] CENGET  SWI                     ; OBTAIN NEXT CHARACTER
1677 f76a 00                               FCB     INCHNP          ; FUNCTION
1678 f76b 81 0d              [ 2 ] CEN2    CMPA    #CR             ; ? END OF ENTRY
1679 f76d 27 0c              [ 3 ]         BEQ     CEND1           ; BRANCH YES
1680 f76f 6d 84              [ 6 ] CENLP1  TST     ,X              ; ? END OF TABLE
1681 f771 2b d2              [ 3 ]         BMI     CBKERR          ; BRANCH ERROR IF SO
1682 f773 a1 81              [ 7 ]         CMPA    ,X++            ; ? THIS THE CHARACTER
1683 f775 26 f8              [ 3 ]         BNE     CENLP1          ; BRANCH IF NOT
1684 f777 eb 1f              [ 5 ]         ADDB    -1,X            ; ADD THIS VALUE
1685 f779 20 ee              [ 3 ]         BRA     CENGET          ; GET NEXT INPUT
1686 f77b 30 8c 49           [ 5 ] CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
1687 f77e 1f 98              [ 6 ]         TFR     B,A             ; SAVE COPY IN A
1688 f780 84 60              [ 2 ]         ANDA    #$60            ; ISOLATE REGISTER MASK
1689 f782 aa e4              [ 4 ]         ORA     ,S              ; ADD IN INDIRECTION BIT
1690 f784 a7 e4              [ 4 ]         STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
1691 f786 c4 9f              [ 2 ]         ANDB    #$9F            ; CLEAR REGISTER BITS
1692 f788 6d 84              [ 6 ] CENLP2  TST     ,X              ; ? END OF TABLE
1693 f78a 27 b9              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
1694 f78c e1 81              [ 7 ]         CMPB    ,X++            ; ? SAME VALUE
1695 f78e 26 f8              [ 3 ]         BNE     CENLP2          ; LOOP IF NOT
1696 f790 e6 1f              [ 5 ]         LDB     -1,X            ; LOAD RESULT VALUE
1697 f792 ea e4              [ 4 ]         ORB     ,S              ; ADD TO BASE SKELETON
1698 f794 e7 e4              [ 4 ]         STB     ,S              ; SAVE POSTBYTE ON STACK
1699 f796 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT
1700 f798 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
1701 f799 04                               FCB     OUT2HS          ; FUNCTION
1702 f79a 3f                 [19 ]         SWI                     ; TO NEXT LINE
1703 f79b 06                               FCB     PCRLF           ; FUNCTION
1704 f79c 35 84              [ 8 ]         PULS    PC,B            ; END OF COMMAND
1705                               
1706                               * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
1707                               CONV1
1708 f79e 41 04 42 05 44 06                FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
1709 f7a6 48 01 48 01 48 00                FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
1710 f7ae 2d 09 2d 01 53 70                FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
1711 f7b6 55 50 58 10 2b 07                FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
1712 f7be 50 80 43 00 52 00                FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
1713 f7c6 ff                               FCB     $FF             ; END OF TABLE
1714                               
1715                               * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
1716                               * BIT SKELETON.
1717                               CONV2
1718 f7c7 10 84 11 00                      FDB     $1084,$1100     ; R,      H,R
1719 f7cb 12 88 13 89                      FDB     $1288,$1389     ; HH,R    HHHH,R
1720 f7cf 14 86 15 85                      FDB     $1486,$1585     ; A,R     B,R
1721 f7d3 16 8b 17 80                      FDB     $168B,$1780     ; D,R     ,R+
1722 f7d7 18 81 19 82                      FDB     $1881,$1982     ; ,R++    ,-R
1723 f7db 1a 83 82 8c                      FDB     $1A83,$828C     ; ,--R    HH,PCR
1724 f7df 83 8d 03 9f                      FDB     $838D,$039F     ; HHHH,PCR [HHHH]
1725 f7e3 00                               FCB     0               ; END OF TABLE
1726                               
1727                               
1728                               *******************************************************
1729                               * FLEX LOADER
1730                               *******************************************************
1731                               
1732                               
1733 c100                          XLOADER  EQU $C100
1734                               
1735 f7e4 bd f7 f5           [ 8 ] FLEX    JSR XINIT
1736                                   
1737 f7e7 bd f8 35           [ 8 ]         JSR XRESTORE
1738                               
1739 f7ea 8e c1 00           [ 3 ]         LDX #XLOADER
1740 f7ed 86 01              [ 2 ]         LDA #1
1741 f7ef bd f8 08           [ 8 ]         JSR XREAD    
1742                               
1743 f7f2 7e c1 00           [ 4 ]         JMP XLOADER
1744                               
1745                               
1746 0002                          DRQ     EQU 2       ; DRQ BIT MASK
1747 0001                          BUSY    EQU 1       ; BUSY MASK
1748 001c                          RDMSK   EQU $1C     ; READ ERROR MASK
1749                               
1750 e810                          PIA     EQU $E810   ; PIA
1751 e810                          PRA     EQU PIA
1752 e810                          DDRA    EQU PIA
1753 e811                          CRA     EQU PIA+1
1754                               
1755 e818                          COMREG  EQU $E818   ; COMMMAND REGISTER
1756 e819                          TRKREG  EQU $E819   ; TRACK REGISTER
1757 e81a                          SECREG  EQU $E81A   ; SECTOR REGISTER
1758 e81b                          DATREG  EQU $E81B   ; DATA REGISTER
1759 008c                          RDCMND  EQU $8C     ; READ COMMAND
1760 0008                          RSCMND  EQU $08     ; RESTORE COMMAND
1761                                
1762                               
1763                                   ; INIT AND WARM
1764                                   ;
1765                                   ; DRIVER INITIALIZATION
1766                               
1767                               
1768 f7f5 4f                 [ 2 ] XINIT   CLRA            ; select PIA control register
1769 f7f6 b7 e8 11           [ 5 ]         STA CRA
1770 f7f9 43                 [ 2 ]         COMA            ; A<-FF
1771 f7fa b7 e8 10           [ 5 ]         STA DDRA        ; all output
1772 f7fd 86 3c              [ 2 ]         LDA #%00111100  ; select PIA output register
1773 f7ff b7 e8 11           [ 5 ]         STA CRA
1774 f802 86 09              [ 2 ]         LDA #%00001001  ; b3=1 (FM)
1775                                                       ; b2=0 (side 0)
1776                                                       ; b1-0 = 01 ( drive 1 select)
1777 f804 b7 e8 10           [ 5 ]         STA PRA
1778                                    
1779 f807 39                 [ 5 ]         RTS         
1780                               
1781                                   ; READ
1782                                   ;
1783                                   ; READ ONE SECTOR
1784                                   ;
1785                                   ; ENTRY -   (X) = Address in memory where sector is to be placed.
1786                                   ;           (A) = Track Number
1787                                   ; EXIT -    (X) May be destroyed
1788                                   ;           (A) May be destroyed
1789                                   ;           (B) = Error condition
1790                                   ;           (Z) = 1 if no error
1791                                   ;               = 0 if an erro
1792                               
1793 f808 86 8c              [ 2 ] XREAD   LDA #RDCMND     ; SETUP READ SECTOR COMMAND
1794 f80a b7 e8 18           [ 5 ]         STA COMREG      ; ISSUE READ COMMAND 
1795 f80d 17 00 32           [ 9 ]         LBSR XDEL28      ; DELAY 
1796 f810 5f                 [ 2 ]         CLRB            ; GET SECTOR LENGTH (=256) 
1797 f811 b6 e8 18           [ 5 ] XREAD3   LDA COMREG      ; GET WD STATUS 
1798 f814 85 02              [ 2 ]         BITA #DRQ       ; CHECK FOR DATA 
1799 f816 26 08              [ 3 ]         BNE XREAD5       ; BRANCH IF DATA PRESENT 
1800 f818 85 01              [ 2 ]         BITA #BUSY      ; CHECK IF BUSY 
1801 f81a 26 f5              [ 3 ]         BNE XREAD3       ; LOOP IF SO 
1802 f81c 1f 89              [ 6 ]         TFR A,B         ; ERROR IF NOT 
1803 f81e 20 0a              [ 3 ]         BRA XREAD6 
1804 f820 b6 e8 1b           [ 5 ] XREAD5   LDA DATREG      ; GET DATA BYTE 
1805 f823 a7 80              [ 6 ]         STA 0,X+        ; PUT IN MEMORY 
1806 f825 5a                 [ 2 ]         DECB            ; DEC THE COUNTER 
1807 f826 26 e9              [ 3 ]         BNE XREAD3       ; LOOP TIL DONE 
1808 f828 8d 03              [ 7 ]         BSR XWAIT        ; WAIT TIL WD IS FINISHED 
1809 f82a c5 1c              [ 2 ] XREAD6   BITB #RDMSK     ; MASK ERRORS 
1810 f82c 39                 [ 5 ]         RTS             ; RETURN
1811                                
1812                                   ; WAIT
1813                                   ;
1814                                   ; WAIT FOR 1771 TO FINISH COMMAND
1815                               
1816 f82d f6 e8 18           [ 5 ] XWAIT    LDB COMREG      ; GET WD STATUS 
1817 f830 c5 01              [ 2 ]         BITB #BUSY      ; CHECK IF BUSY 
1818 f832 26 f9              [ 3 ]         BNE XWAIT        ; LOOP TIL NOT BUSY 
1819 f834 39                 [ 5 ]         RTS             ; RETURN
1820                               
1821                                   ; RESTORE
1822                               
1823 f835 86 08              [ 2 ] XRESTORE LDA #RSCMND     ; SETUP RESTORE COMMAND 
1824 f837 b7 e8 18           [ 5 ]         STA COMREG      ; ISSUE RESTORE COMMAND 
1825 f83a 8d 06              [ 7 ]         BSR XDEL28       ; DELAY 
1826 f83c 17 ff ee           [ 9 ]         LBSR XWAIT       ; WAIT TIL WD IS FINISHED 
1827 f83f c5 d8              [ 2 ]         BITB #$D8       ; CHECK FOR ERROR 
1828 f841 39                 [ 5 ]         RTS             ; RETURN
1829                                
1830                                   ; DELAY
1831                               
1832 f842 17 00 00           [ 9 ] XDEL28   LBSR XDEL14 
1833 f845 17 00 00           [ 9 ] XDEL14   LBSR XDEL 
1834 f848 39                 [ 5 ] XDEL     RTS
1835                               
1836                               
1837                               ****************************************************
1838                               *            DEFAULT INTERRUPT TRANSFERS           *
1839                               ****************************************************
1840 f849 6e 9d ef 79        [11 ] RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
1841 f84d 6e 9d ef 77        [11 ] SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
1842 f851 6e 9d ef 75        [11 ] SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
1843 f855 6e 9d ef 73        [11 ] FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
1844 f859 6e 9d ef 71        [11 ] IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
1845 f85d 6e 9d ef 6f        [11 ] SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
1846 f861 6e 9d ef 6d        [11 ] NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
1847                               
1848                               ******************************************************
1849                               *            ASSIST09 HARDWARE VECTOR TABLE
1850                               * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
1851                               * THE MC6809 HARDWARE VECTORS.
1852                               ******************************************************
1853 fff0                                  ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
1854 fff0 f8 49                            FDB     RSRVD           ; RESERVED SLOT
1855 fff2 f8 4d                            FDB     SWI3            ; SOFTWARE INTERRUPT 3
1856 fff4 f8 51                            FDB     SWI2            ; SOFTWARE INTERRUPT 2
1857 fff6 f8 55                            FDB     FIRQ            ; FAST INTERRUPT REQUEST
1858 fff8 f8 59                            FDB     IRQ             ; INTERRUPT REQUEST
1859 fffa f8 5d                            FDB     SWI             ; SOFTWARE INTERRUPT
1860 fffc f8 61                            FDB     NMI             ; NON-MASKABLE INTERRUPT
1861 fffe f0 37                            FDB     RESET           ; RESTART
1862                               
1863                               
